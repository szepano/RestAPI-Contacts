<!DOCTYPE html>

<html lang="en" data-content_root="../../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>passlib.context &#8212; contacts_api 0.1 documentation</title>
    <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=a746c00c" />
    <link rel="stylesheet" type="text/css" href="../../_static/nature.css?v=0f882399" />
    <script src="../../_static/documentation_options.js?v=2709fde1"></script>
    <script src="../../_static/doctools.js?v=9a2dae69"></script>
    <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../index.html">contacts_api 0.1 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../index.html" accesskey="U">Module code</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">passlib.context</a></li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for passlib.context</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;passlib.context - CryptContext implementation&quot;&quot;&quot;</span>
<span class="c1">#=============================================================================</span>
<span class="c1"># imports</span>
<span class="c1">#=============================================================================</span>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">with_statement</span>
<span class="c1"># core</span>
<span class="kn">import</span> <span class="nn">re</span>
<span class="kn">import</span> <span class="nn">logging</span><span class="p">;</span> <span class="n">log</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="vm">__name__</span><span class="p">)</span>
<span class="kn">import</span> <span class="nn">threading</span>
<span class="kn">import</span> <span class="nn">time</span>
<span class="kn">from</span> <span class="nn">warnings</span> <span class="kn">import</span> <span class="n">warn</span>
<span class="c1"># site</span>
<span class="c1"># pkg</span>
<span class="kn">from</span> <span class="nn">passlib</span> <span class="kn">import</span> <span class="n">exc</span>
<span class="kn">from</span> <span class="nn">passlib.exc</span> <span class="kn">import</span> <span class="n">ExpectedStringError</span><span class="p">,</span> <span class="n">ExpectedTypeError</span><span class="p">,</span> <span class="n">PasslibConfigWarning</span>
<span class="kn">from</span> <span class="nn">passlib.registry</span> <span class="kn">import</span> <span class="n">get_crypt_handler</span><span class="p">,</span> <span class="n">_validate_handler_name</span>
<span class="kn">from</span> <span class="nn">passlib.utils</span> <span class="kn">import</span> <span class="p">(</span><span class="n">handlers</span> <span class="k">as</span> <span class="n">uh</span><span class="p">,</span> <span class="n">to_bytes</span><span class="p">,</span>
                           <span class="n">to_unicode</span><span class="p">,</span> <span class="n">splitcomma</span><span class="p">,</span>
                           <span class="n">as_bool</span><span class="p">,</span> <span class="n">timer</span><span class="p">,</span> <span class="n">rng</span><span class="p">,</span> <span class="n">getrandstr</span><span class="p">,</span>
                           <span class="p">)</span>
<span class="kn">from</span> <span class="nn">passlib.utils.binary</span> <span class="kn">import</span> <span class="n">BASE64_CHARS</span>
<span class="kn">from</span> <span class="nn">passlib.utils.compat</span> <span class="kn">import</span> <span class="p">(</span><span class="n">iteritems</span><span class="p">,</span> <span class="n">num_types</span><span class="p">,</span> <span class="n">irange</span><span class="p">,</span>
                                  <span class="n">PY2</span><span class="p">,</span> <span class="n">PY3</span><span class="p">,</span> <span class="n">unicode</span><span class="p">,</span> <span class="n">SafeConfigParser</span><span class="p">,</span>
                                  <span class="n">NativeStringIO</span><span class="p">,</span> <span class="n">BytesIO</span><span class="p">,</span>
                                  <span class="n">unicode_or_bytes_types</span><span class="p">,</span> <span class="n">native_string_types</span><span class="p">,</span>
                                  <span class="p">)</span>
<span class="kn">from</span> <span class="nn">passlib.utils.decor</span> <span class="kn">import</span> <span class="n">deprecated_method</span><span class="p">,</span> <span class="n">memoized_property</span>
<span class="c1"># local</span>
<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span>
    <span class="s1">&#39;CryptContext&#39;</span><span class="p">,</span>
    <span class="s1">&#39;LazyCryptContext&#39;</span><span class="p">,</span>
    <span class="s1">&#39;CryptPolicy&#39;</span><span class="p">,</span>
<span class="p">]</span>

<span class="c1">#=============================================================================</span>
<span class="c1"># support</span>
<span class="c1">#=============================================================================</span>

<span class="c1"># private object to detect unset params</span>
<span class="n">_UNSET</span> <span class="o">=</span> <span class="nb">object</span><span class="p">()</span>

<span class="k">def</span> <span class="nf">_coerce_vary_rounds</span><span class="p">(</span><span class="n">value</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;parse vary_rounds string to percent as [0,1) float, or integer&quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">value</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s2">&quot;%&quot;</span><span class="p">):</span>
        <span class="c1"># XXX: deprecate this in favor of raw float?</span>
        <span class="k">return</span> <span class="nb">float</span><span class="p">(</span><span class="n">value</span><span class="o">.</span><span class="n">rstrip</span><span class="p">(</span><span class="s2">&quot;%&quot;</span><span class="p">))</span><span class="o">*</span><span class="mf">.01</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">return</span> <span class="nb">int</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
        <span class="k">return</span> <span class="nb">float</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>

<span class="c1"># set of options which aren&#39;t allowed to be set via policy</span>
<span class="n">_forbidden_scheme_options</span> <span class="o">=</span> <span class="nb">set</span><span class="p">([</span><span class="s2">&quot;salt&quot;</span><span class="p">])</span>
    <span class="c1"># &#39;salt&#39; - not allowed since a fixed salt would defeat the purpose.</span>

<span class="c1"># dict containing funcs used to coerce strings to correct type for scheme option keys.</span>
<span class="c1"># NOTE: this isn&#39;t really needed any longer, since Handler.using() handles the actual parsing.</span>
<span class="c1">#       keeping this around for now, though, since it makes context.to_dict() output cleaner.</span>
<span class="n">_coerce_scheme_options</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span>
    <span class="n">min_rounds</span><span class="o">=</span><span class="nb">int</span><span class="p">,</span>
    <span class="n">max_rounds</span><span class="o">=</span><span class="nb">int</span><span class="p">,</span>
    <span class="n">default_rounds</span><span class="o">=</span><span class="nb">int</span><span class="p">,</span>
    <span class="n">vary_rounds</span><span class="o">=</span><span class="n">_coerce_vary_rounds</span><span class="p">,</span>
    <span class="n">salt_size</span><span class="o">=</span><span class="nb">int</span><span class="p">,</span>
<span class="p">)</span>

<span class="k">def</span> <span class="nf">_is_handler_registered</span><span class="p">(</span><span class="n">handler</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;detect if handler is registered or a custom handler&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">get_crypt_handler</span><span class="p">(</span><span class="n">handler</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">is</span> <span class="n">handler</span>

<span class="nd">@staticmethod</span>
<span class="k">def</span> <span class="nf">_always_needs_update</span><span class="p">(</span><span class="nb">hash</span><span class="p">,</span> <span class="n">secret</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    dummy function patched into handler.needs_update() by _CryptConfig</span>
<span class="sd">    when hash alg has been deprecated for context.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="kc">True</span>

<span class="c1">#: list of keys allowed under wildcard &quot;all&quot; scheme w/o a security warning.</span>
<span class="n">_global_settings</span> <span class="o">=</span> <span class="nb">set</span><span class="p">([</span><span class="s2">&quot;truncate_error&quot;</span><span class="p">,</span> <span class="s2">&quot;vary_rounds&quot;</span><span class="p">])</span>

<span class="c1">#=============================================================================</span>
<span class="c1"># crypt policy</span>
<span class="c1">#=============================================================================</span>
<span class="n">_preamble</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;The CryptPolicy class has been deprecated as of &quot;</span>
             <span class="s2">&quot;Passlib 1.6, and will be removed in Passlib 1.8. &quot;</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">CryptPolicy</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    .. deprecated:: 1.6</span>
<span class="sd">        This class has been deprecated, and will be removed in Passlib 1.8.</span>
<span class="sd">        All of its functionality has been rolled into :class:`CryptContext`.</span>

<span class="sd">    This class previously stored the configuration options for the</span>
<span class="sd">    CryptContext class. In the interest of interface simplification,</span>
<span class="sd">    all of this class&#39; functionality has been rolled into the CryptContext</span>
<span class="sd">    class itself.</span>
<span class="sd">    The documentation for this class is now focused on  documenting how to</span>
<span class="sd">    migrate to the new api. Additionally, where possible, the deprecation</span>
<span class="sd">    warnings issued by the CryptPolicy methods will list the replacement call</span>
<span class="sd">    that should be used.</span>

<span class="sd">    Constructors</span>
<span class="sd">    ============</span>
<span class="sd">    CryptPolicy objects can be constructed directly using any of</span>
<span class="sd">    the keywords accepted by :class:`CryptContext`. Direct uses of the</span>
<span class="sd">    :class:`!CryptPolicy` constructor should either pass the keywords</span>
<span class="sd">    directly into the CryptContext constructor, or to :meth:`CryptContext.update`</span>
<span class="sd">    if the policy object was being used to update an existing context object.</span>

<span class="sd">    In addition to passing in keywords directly,</span>
<span class="sd">    CryptPolicy objects can be constructed by the following methods:</span>

<span class="sd">    .. automethod:: from_path</span>
<span class="sd">    .. automethod:: from_string</span>
<span class="sd">    .. automethod:: from_source</span>
<span class="sd">    .. automethod:: from_sources</span>
<span class="sd">    .. automethod:: replace</span>

<span class="sd">    Introspection</span>
<span class="sd">    =============</span>
<span class="sd">    All of the informational methods provided by this class have been deprecated</span>
<span class="sd">    by identical or similar methods in the :class:`CryptContext` class:</span>

<span class="sd">    .. automethod:: has_schemes</span>
<span class="sd">    .. automethod:: schemes</span>
<span class="sd">    .. automethod:: iter_handlers</span>
<span class="sd">    .. automethod:: get_handler</span>
<span class="sd">    .. automethod:: get_options</span>
<span class="sd">    .. automethod:: handler_is_deprecated</span>
<span class="sd">    .. automethod:: get_min_verify_time</span>

<span class="sd">    Exporting</span>
<span class="sd">    =========</span>
<span class="sd">    .. automethod:: iter_config</span>
<span class="sd">    .. automethod:: to_dict</span>
<span class="sd">    .. automethod:: to_file</span>
<span class="sd">    .. automethod:: to_string</span>

<span class="sd">    .. note::</span>
<span class="sd">        CryptPolicy are immutable.</span>
<span class="sd">        Use the :meth:`replace` method to mutate existing instances.</span>

<span class="sd">    .. deprecated:: 1.6</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1">#===================================================================</span>
    <span class="c1"># class methods</span>
    <span class="c1">#===================================================================</span>
    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_path</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="n">section</span><span class="o">=</span><span class="s2">&quot;passlib&quot;</span><span class="p">,</span> <span class="n">encoding</span><span class="o">=</span><span class="s2">&quot;utf-8&quot;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;create a CryptPolicy instance from a local file.</span>

<span class="sd">        .. deprecated:: 1.6</span>

<span class="sd">        Creating a new CryptContext from a file, which was previously done via</span>
<span class="sd">        ``CryptContext(policy=CryptPolicy.from_path(path))``, can now be</span>
<span class="sd">        done via ``CryptContext.from_path(path)``.</span>
<span class="sd">        See :meth:`CryptContext.from_path` for details.</span>

<span class="sd">        Updating an existing CryptContext from a file, which was previously done</span>
<span class="sd">        ``context.policy = CryptPolicy.from_path(path)``, can now be</span>
<span class="sd">        done via ``context.load_path(path)``.</span>
<span class="sd">        See :meth:`CryptContext.load_path` for details.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">warn</span><span class="p">(</span><span class="n">_preamble</span> <span class="o">+</span>
             <span class="s2">&quot;Instead of ``CryptPolicy.from_path(path)``, &quot;</span>
             <span class="s2">&quot;use ``CryptContext.from_path(path)`` &quot;</span>
             <span class="s2">&quot; or ``context.load_path(path)`` for an existing CryptContext.&quot;</span><span class="p">,</span>
             <span class="ne">DeprecationWarning</span><span class="p">,</span> <span class="n">stacklevel</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="n">_internal_context</span><span class="o">=</span><span class="n">CryptContext</span><span class="o">.</span><span class="n">from_path</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">section</span><span class="p">,</span>
                                                            <span class="n">encoding</span><span class="p">))</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_string</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">source</span><span class="p">,</span> <span class="n">section</span><span class="o">=</span><span class="s2">&quot;passlib&quot;</span><span class="p">,</span> <span class="n">encoding</span><span class="o">=</span><span class="s2">&quot;utf-8&quot;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;create a CryptPolicy instance from a string.</span>

<span class="sd">        .. deprecated:: 1.6</span>

<span class="sd">        Creating a new CryptContext from a string, which was previously done via</span>
<span class="sd">        ``CryptContext(policy=CryptPolicy.from_string(data))``, can now be</span>
<span class="sd">        done via ``CryptContext.from_string(data)``.</span>
<span class="sd">        See :meth:`CryptContext.from_string` for details.</span>

<span class="sd">        Updating an existing CryptContext from a string, which was previously done</span>
<span class="sd">        ``context.policy = CryptPolicy.from_string(data)``, can now be</span>
<span class="sd">        done via ``context.load(data)``.</span>
<span class="sd">        See :meth:`CryptContext.load` for details.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">warn</span><span class="p">(</span><span class="n">_preamble</span> <span class="o">+</span>
             <span class="s2">&quot;Instead of ``CryptPolicy.from_string(source)``, &quot;</span>
             <span class="s2">&quot;use ``CryptContext.from_string(source)`` or &quot;</span>
             <span class="s2">&quot;``context.load(source)`` for an existing CryptContext.&quot;</span><span class="p">,</span>
             <span class="ne">DeprecationWarning</span><span class="p">,</span> <span class="n">stacklevel</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="n">_internal_context</span><span class="o">=</span><span class="n">CryptContext</span><span class="o">.</span><span class="n">from_string</span><span class="p">(</span><span class="n">source</span><span class="p">,</span> <span class="n">section</span><span class="p">,</span>
                                                              <span class="n">encoding</span><span class="p">))</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_source</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">source</span><span class="p">,</span> <span class="n">_warn</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;create a CryptPolicy instance from some source.</span>

<span class="sd">        this method autodetects the source type, and invokes</span>
<span class="sd">        the appropriate constructor automatically. it attempts</span>
<span class="sd">        to detect whether the source is a configuration string, a filepath,</span>
<span class="sd">        a dictionary, or an existing CryptPolicy instance.</span>

<span class="sd">        .. deprecated:: 1.6</span>

<span class="sd">        Create a new CryptContext, which could previously be done via</span>
<span class="sd">        ``CryptContext(policy=CryptPolicy.from_source(source))``, should</span>
<span class="sd">        now be done using an explicit method: the :class:`CryptContext`</span>
<span class="sd">        constructor itself, :meth:`CryptContext.from_path`,</span>
<span class="sd">        or :meth:`CryptContext.from_string`.</span>

<span class="sd">        Updating an existing CryptContext, which could previously be done via</span>
<span class="sd">        ``context.policy = CryptPolicy.from_source(source)``, should</span>
<span class="sd">        now be done using an explicit method: :meth:`CryptContext.update`,</span>
<span class="sd">        or :meth:`CryptContext.load`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">_warn</span><span class="p">:</span>
            <span class="n">warn</span><span class="p">(</span><span class="n">_preamble</span> <span class="o">+</span>
                 <span class="s2">&quot;Instead of ``CryptPolicy.from_source()``, &quot;</span>
                 <span class="s2">&quot;use ``CryptContext.from_string(path)`` &quot;</span>
                 <span class="s2">&quot; or ``CryptContext.from_path(source)``, as appropriate.&quot;</span><span class="p">,</span>
                 <span class="ne">DeprecationWarning</span><span class="p">,</span> <span class="n">stacklevel</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">source</span><span class="p">,</span> <span class="n">CryptPolicy</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">source</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">source</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="n">_internal_context</span><span class="o">=</span><span class="n">CryptContext</span><span class="p">(</span><span class="o">**</span><span class="n">source</span><span class="p">))</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">source</span><span class="p">,</span> <span class="p">(</span><span class="nb">bytes</span><span class="p">,</span><span class="n">unicode</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;source must be CryptPolicy, dict, config string, &quot;</span>
                            <span class="s2">&quot;or file path: </span><span class="si">%r</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">source</span><span class="p">),))</span>
        <span class="k">elif</span> <span class="nb">any</span><span class="p">(</span><span class="n">c</span> <span class="ow">in</span> <span class="n">source</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="s2">&quot;</span><span class="se">\n\r\t</span><span class="s2">&quot;</span><span class="p">)</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">source</span><span class="o">.</span><span class="n">strip</span><span class="p">(</span><span class="s2">&quot; </span><span class="se">\t</span><span class="s2">./;:&quot;</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="n">_internal_context</span><span class="o">=</span><span class="n">CryptContext</span><span class="o">.</span><span class="n">from_string</span><span class="p">(</span><span class="n">source</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="n">_internal_context</span><span class="o">=</span><span class="n">CryptContext</span><span class="o">.</span><span class="n">from_path</span><span class="p">(</span><span class="n">source</span><span class="p">))</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_sources</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">sources</span><span class="p">,</span> <span class="n">_warn</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;create a CryptPolicy instance by merging multiple sources.</span>

<span class="sd">        each source is interpreted as by :meth:`from_source`,</span>
<span class="sd">        and the results are merged together.</span>

<span class="sd">        .. deprecated:: 1.6</span>
<span class="sd">            Instead of using this method to merge multiple policies together,</span>
<span class="sd">            a :class:`CryptContext` instance should be created, and then</span>
<span class="sd">            the multiple sources merged together via :meth:`CryptContext.load`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">_warn</span><span class="p">:</span>
            <span class="n">warn</span><span class="p">(</span><span class="n">_preamble</span> <span class="o">+</span>
                 <span class="s2">&quot;Instead of ``CryptPolicy.from_sources()``, &quot;</span>
                 <span class="s2">&quot;use the various CryptContext constructors &quot;</span>
                 <span class="s2">&quot; followed by ``context.update()``.&quot;</span><span class="p">,</span>
                 <span class="ne">DeprecationWarning</span><span class="p">,</span> <span class="n">stacklevel</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">sources</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;no sources specified&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">sources</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="n">from_source</span><span class="p">(</span><span class="n">sources</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">_warn</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">kwds</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">source</span> <span class="ow">in</span> <span class="n">sources</span><span class="p">:</span>
            <span class="n">kwds</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="bp">cls</span><span class="o">.</span><span class="n">from_source</span><span class="p">(</span><span class="n">source</span><span class="p">,</span> <span class="n">_warn</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span><span class="o">.</span><span class="n">_context</span><span class="o">.</span><span class="n">to_dict</span><span class="p">(</span><span class="n">resolve</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="n">_internal_context</span><span class="o">=</span><span class="n">CryptContext</span><span class="p">(</span><span class="o">**</span><span class="n">kwds</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">replace</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;create a new CryptPolicy, optionally updating parts of the</span>
<span class="sd">        existing configuration.</span>

<span class="sd">        .. deprecated:: 1.6</span>
<span class="sd">            Callers of this method should :meth:`CryptContext.update` or</span>
<span class="sd">            :meth:`CryptContext.copy` instead.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_stub_policy</span><span class="p">:</span>
            <span class="n">warn</span><span class="p">(</span><span class="n">_preamble</span> <span class="o">+</span> <span class="c1"># pragma: no cover -- deprecated &amp; unused</span>
                 <span class="s2">&quot;Instead of ``context.policy.replace()``, &quot;</span>
                 <span class="s2">&quot;use ``context.update()`` or ``context.copy()``.&quot;</span><span class="p">,</span>
                 <span class="ne">DeprecationWarning</span><span class="p">,</span> <span class="n">stacklevel</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">warn</span><span class="p">(</span><span class="n">_preamble</span> <span class="o">+</span>
                 <span class="s2">&quot;Instead of ``CryptPolicy().replace()``, &quot;</span>
                 <span class="s2">&quot;create a CryptContext instance and &quot;</span>
                 <span class="s2">&quot;use ``context.update()`` or ``context.copy()``.&quot;</span><span class="p">,</span>
                 <span class="ne">DeprecationWarning</span><span class="p">,</span> <span class="n">stacklevel</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">sources</span> <span class="o">=</span> <span class="p">[</span> <span class="bp">self</span> <span class="p">]</span>
        <span class="k">if</span> <span class="n">args</span><span class="p">:</span>
            <span class="n">sources</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">kwds</span><span class="p">:</span>
            <span class="n">sources</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">kwds</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">CryptPolicy</span><span class="o">.</span><span class="n">from_sources</span><span class="p">(</span><span class="n">sources</span><span class="p">,</span> <span class="n">_warn</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

    <span class="c1">#===================================================================</span>
    <span class="c1"># instance attrs</span>
    <span class="c1">#===================================================================</span>

    <span class="c1"># internal CryptContext we&#39;re wrapping to handle everything</span>
    <span class="c1"># until this class is removed.</span>
    <span class="n">_context</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="c1"># flag indicating this is wrapper generated by the CryptContext.policy</span>
    <span class="c1"># attribute, rather than one created independantly by the application.</span>
    <span class="n">_stub_policy</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="c1">#===================================================================</span>
    <span class="c1"># init</span>
    <span class="c1">#===================================================================</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">):</span>
        <span class="n">context</span> <span class="o">=</span> <span class="n">kwds</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;_internal_context&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">context</span><span class="p">:</span>
            <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">context</span><span class="p">,</span> <span class="n">CryptContext</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_context</span> <span class="o">=</span> <span class="n">context</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_stub_policy</span> <span class="o">=</span> <span class="n">kwds</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;_stub_policy&quot;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
            <span class="k">assert</span> <span class="ow">not</span> <span class="p">(</span><span class="n">args</span> <span class="ow">or</span> <span class="n">kwds</span><span class="p">),</span> <span class="s2">&quot;unexpected args: </span><span class="si">%r</span><span class="s2"> </span><span class="si">%r</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">args</span><span class="p">,</span><span class="n">kwds</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">args</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;only one positional argument accepted&quot;</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">kwds</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;cannot specify positional arg and kwds&quot;</span><span class="p">)</span>
                <span class="n">kwds</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">warn</span><span class="p">(</span><span class="n">_preamble</span> <span class="o">+</span>
                 <span class="s2">&quot;Instead of constructing a CryptPolicy instance, &quot;</span>
                 <span class="s2">&quot;create a CryptContext directly, or use ``context.update()`` &quot;</span>
                 <span class="s2">&quot;and ``context.load()`` to reconfigure existing CryptContext &quot;</span>
                 <span class="s2">&quot;instances.&quot;</span><span class="p">,</span>
                 <span class="ne">DeprecationWarning</span><span class="p">,</span> <span class="n">stacklevel</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_context</span> <span class="o">=</span> <span class="n">CryptContext</span><span class="p">(</span><span class="o">**</span><span class="n">kwds</span><span class="p">)</span>

    <span class="c1">#===================================================================</span>
    <span class="c1"># public interface for examining options</span>
    <span class="c1">#===================================================================</span>
    <span class="k">def</span> <span class="nf">has_schemes</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;return True if policy defines *any* schemes for use.</span>

<span class="sd">        .. deprecated:: 1.6</span>
<span class="sd">            applications should use ``bool(context.schemes())`` instead.</span>
<span class="sd">            see :meth:`CryptContext.schemes`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_stub_policy</span><span class="p">:</span>
            <span class="n">warn</span><span class="p">(</span><span class="n">_preamble</span> <span class="o">+</span> <span class="c1"># pragma: no cover -- deprecated &amp; unused</span>
                 <span class="s2">&quot;Instead of ``context.policy.has_schemes()``, &quot;</span>
                 <span class="s2">&quot;use ``bool(context.schemes())``.&quot;</span><span class="p">,</span>
                 <span class="ne">DeprecationWarning</span><span class="p">,</span> <span class="n">stacklevel</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">warn</span><span class="p">(</span><span class="n">_preamble</span> <span class="o">+</span>
                 <span class="s2">&quot;Instead of ``CryptPolicy().has_schemes()``, &quot;</span>
                 <span class="s2">&quot;create a CryptContext instance and &quot;</span>
                 <span class="s2">&quot;use ``bool(context.schemes())``.&quot;</span><span class="p">,</span>
                 <span class="ne">DeprecationWarning</span><span class="p">,</span> <span class="n">stacklevel</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">bool</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_context</span><span class="o">.</span><span class="n">schemes</span><span class="p">())</span>

    <span class="k">def</span> <span class="nf">iter_handlers</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;return iterator over handlers defined in policy.</span>

<span class="sd">        .. deprecated:: 1.6</span>
<span class="sd">            applications should use ``context.schemes(resolve=True))`` instead.</span>
<span class="sd">            see :meth:`CryptContext.schemes`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_stub_policy</span><span class="p">:</span>
            <span class="n">warn</span><span class="p">(</span><span class="n">_preamble</span> <span class="o">+</span>
                 <span class="s2">&quot;Instead of ``context.policy.iter_handlers()``, &quot;</span>
                 <span class="s2">&quot;use ``context.schemes(resolve=True)``.&quot;</span><span class="p">,</span>
                 <span class="ne">DeprecationWarning</span><span class="p">,</span> <span class="n">stacklevel</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">warn</span><span class="p">(</span><span class="n">_preamble</span> <span class="o">+</span>
                 <span class="s2">&quot;Instead of ``CryptPolicy().iter_handlers()``, &quot;</span>
                 <span class="s2">&quot;create a CryptContext instance and &quot;</span>
                 <span class="s2">&quot;use ``context.schemes(resolve=True)``.&quot;</span><span class="p">,</span>
                 <span class="ne">DeprecationWarning</span><span class="p">,</span> <span class="n">stacklevel</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_context</span><span class="o">.</span><span class="n">schemes</span><span class="p">(</span><span class="n">resolve</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">unconfigured</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">schemes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">resolve</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;return list of schemes defined in policy.</span>

<span class="sd">        .. deprecated:: 1.6</span>
<span class="sd">            applications should use :meth:`CryptContext.schemes` instead.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_stub_policy</span><span class="p">:</span>
            <span class="n">warn</span><span class="p">(</span><span class="n">_preamble</span> <span class="o">+</span> <span class="c1"># pragma: no cover -- deprecated &amp; unused</span>
                 <span class="s2">&quot;Instead of ``context.policy.schemes()``, &quot;</span>
                 <span class="s2">&quot;use ``context.schemes()``.&quot;</span><span class="p">,</span>
                 <span class="ne">DeprecationWarning</span><span class="p">,</span> <span class="n">stacklevel</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">warn</span><span class="p">(</span><span class="n">_preamble</span> <span class="o">+</span>
                 <span class="s2">&quot;Instead of ``CryptPolicy().schemes()``, &quot;</span>
                 <span class="s2">&quot;create a CryptContext instance and &quot;</span>
                 <span class="s2">&quot;use ``context.schemes()``.&quot;</span><span class="p">,</span>
                 <span class="ne">DeprecationWarning</span><span class="p">,</span> <span class="n">stacklevel</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_context</span><span class="o">.</span><span class="n">schemes</span><span class="p">(</span><span class="n">resolve</span><span class="o">=</span><span class="n">resolve</span><span class="p">,</span> <span class="n">unconfigured</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">get_handler</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">category</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">required</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;return handler as specified by name, or default handler.</span>

<span class="sd">        .. deprecated:: 1.6</span>
<span class="sd">            applications should use :meth:`CryptContext.handler` instead,</span>
<span class="sd">            though note that the ``required`` keyword has been removed,</span>
<span class="sd">            and the new method will always act as if ``required=True``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_stub_policy</span><span class="p">:</span>
            <span class="n">warn</span><span class="p">(</span><span class="n">_preamble</span> <span class="o">+</span>
                 <span class="s2">&quot;Instead of ``context.policy.get_handler()``, &quot;</span>
                 <span class="s2">&quot;use ``context.handler()``.&quot;</span><span class="p">,</span>
                 <span class="ne">DeprecationWarning</span><span class="p">,</span> <span class="n">stacklevel</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">warn</span><span class="p">(</span><span class="n">_preamble</span> <span class="o">+</span>
                 <span class="s2">&quot;Instead of ``CryptPolicy().get_handler()``, &quot;</span>
                 <span class="s2">&quot;create a CryptContext instance and &quot;</span>
                 <span class="s2">&quot;use ``context.handler()``.&quot;</span><span class="p">,</span>
                 <span class="ne">DeprecationWarning</span><span class="p">,</span> <span class="n">stacklevel</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
        <span class="c1"># CryptContext.handler() doesn&#39;t support required=False,</span>
        <span class="c1"># so wrapping it in try/except</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_context</span><span class="o">.</span><span class="n">handler</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">category</span><span class="p">,</span> <span class="n">unconfigured</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">required</span><span class="p">:</span>
                <span class="k">raise</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="nf">get_min_verify_time</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">category</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;get min_verify_time setting for policy.</span>

<span class="sd">        .. deprecated:: 1.6</span>
<span class="sd">            min_verify_time option will be removed entirely in passlib 1.8</span>

<span class="sd">        .. versionchanged:: 1.7</span>
<span class="sd">            this method now always returns the value automatically</span>
<span class="sd">            calculated by :meth:`CryptContext.min_verify_time`,</span>
<span class="sd">            any value specified by policy is ignored.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">warn</span><span class="p">(</span><span class="s2">&quot;get_min_verify_time() and min_verify_time option is deprecated and ignored, &quot;</span>
             <span class="s2">&quot;and will be removed in Passlib 1.8&quot;</span><span class="p">,</span> <span class="ne">DeprecationWarning</span><span class="p">,</span>
             <span class="n">stacklevel</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
        <span class="k">return</span> <span class="mi">0</span>

    <span class="k">def</span> <span class="nf">get_options</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">category</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;return dictionary of options specific to a given handler.</span>

<span class="sd">        .. deprecated:: 1.6</span>
<span class="sd">            this method has no direct replacement in the 1.6 api, as there</span>
<span class="sd">            is not a clearly defined use-case. however, examining the output of</span>
<span class="sd">            :meth:`CryptContext.to_dict` should serve as the closest alternative.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># XXX: might make a public replacement, but need more study of the use cases.</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_stub_policy</span><span class="p">:</span>
            <span class="n">warn</span><span class="p">(</span><span class="n">_preamble</span> <span class="o">+</span> <span class="c1"># pragma: no cover -- deprecated &amp; unused</span>
                 <span class="s2">&quot;``context.policy.get_options()`` will no longer be available.&quot;</span><span class="p">,</span>
                 <span class="ne">DeprecationWarning</span><span class="p">,</span> <span class="n">stacklevel</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">warn</span><span class="p">(</span><span class="n">_preamble</span> <span class="o">+</span>
                 <span class="s2">&quot;``CryptPolicy().get_options()`` will no longer be available.&quot;</span><span class="p">,</span>
                 <span class="ne">DeprecationWarning</span><span class="p">,</span> <span class="n">stacklevel</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="s2">&quot;name&quot;</span><span class="p">):</span>
            <span class="n">name</span> <span class="o">=</span> <span class="n">name</span><span class="o">.</span><span class="n">name</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_context</span><span class="o">.</span><span class="n">_config</span><span class="o">.</span><span class="n">_get_record_options_with_flag</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">category</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">handler_is_deprecated</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">category</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;check if handler has been deprecated by policy.</span>

<span class="sd">        .. deprecated:: 1.6</span>
<span class="sd">            this method has no direct replacement in the 1.6 api, as there</span>
<span class="sd">            is not a clearly defined use-case. however, examining the output of</span>
<span class="sd">            :meth:`CryptContext.to_dict` should serve as the closest alternative.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># XXX: might make a public replacement, but need more study of the use cases.</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_stub_policy</span><span class="p">:</span>
            <span class="n">warn</span><span class="p">(</span><span class="n">_preamble</span> <span class="o">+</span>
                 <span class="s2">&quot;``context.policy.handler_is_deprecated()`` will no longer be available.&quot;</span><span class="p">,</span>
                 <span class="ne">DeprecationWarning</span><span class="p">,</span> <span class="n">stacklevel</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">warn</span><span class="p">(</span><span class="n">_preamble</span> <span class="o">+</span>
                 <span class="s2">&quot;``CryptPolicy().handler_is_deprecated()`` will no longer be available.&quot;</span><span class="p">,</span>
                 <span class="ne">DeprecationWarning</span><span class="p">,</span> <span class="n">stacklevel</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="s2">&quot;name&quot;</span><span class="p">):</span>
            <span class="n">name</span> <span class="o">=</span> <span class="n">name</span><span class="o">.</span><span class="n">name</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_context</span><span class="o">.</span><span class="n">handler</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">category</span><span class="p">)</span><span class="o">.</span><span class="n">deprecated</span>

    <span class="c1">#===================================================================</span>
    <span class="c1"># serialization</span>
    <span class="c1">#===================================================================</span>

    <span class="k">def</span> <span class="nf">iter_config</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ini</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">resolve</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;iterate over key/value pairs representing the policy object.</span>

<span class="sd">        .. deprecated:: 1.6</span>
<span class="sd">            applications should use :meth:`CryptContext.to_dict` instead.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_stub_policy</span><span class="p">:</span>
            <span class="n">warn</span><span class="p">(</span><span class="n">_preamble</span> <span class="o">+</span> <span class="c1"># pragma: no cover -- deprecated &amp; unused</span>
                 <span class="s2">&quot;Instead of ``context.policy.iter_config()``, &quot;</span>
                 <span class="s2">&quot;use ``context.to_dict().items()``.&quot;</span><span class="p">,</span>
                 <span class="ne">DeprecationWarning</span><span class="p">,</span> <span class="n">stacklevel</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">warn</span><span class="p">(</span><span class="n">_preamble</span> <span class="o">+</span>
                 <span class="s2">&quot;Instead of ``CryptPolicy().iter_config()``, &quot;</span>
                 <span class="s2">&quot;create a CryptContext instance and &quot;</span>
                 <span class="s2">&quot;use ``context.to_dict().items()``.&quot;</span><span class="p">,</span>
                 <span class="ne">DeprecationWarning</span><span class="p">,</span> <span class="n">stacklevel</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
        <span class="c1"># hacked code that renders keys &amp; values in manner that approximates</span>
        <span class="c1"># old behavior. context.to_dict() is much cleaner.</span>
        <span class="n">context</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_context</span>
        <span class="k">if</span> <span class="n">ini</span><span class="p">:</span>
            <span class="k">def</span> <span class="nf">render_key</span><span class="p">(</span><span class="n">key</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">context</span><span class="o">.</span><span class="n">_render_config_key</span><span class="p">(</span><span class="n">key</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;__&quot;</span><span class="p">,</span> <span class="s2">&quot;.&quot;</span><span class="p">)</span>
            <span class="k">def</span> <span class="nf">render_value</span><span class="p">(</span><span class="n">value</span><span class="p">):</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span><span class="nb">tuple</span><span class="p">)):</span>
                    <span class="n">value</span> <span class="o">=</span> <span class="s2">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">value</span>
            <span class="n">resolve</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">render_key</span> <span class="o">=</span> <span class="n">context</span><span class="o">.</span><span class="n">_render_config_key</span>
            <span class="n">render_value</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">value</span><span class="p">:</span> <span class="n">value</span>
        <span class="k">return</span> <span class="p">(</span>
            <span class="p">(</span><span class="n">render_key</span><span class="p">(</span><span class="n">key</span><span class="p">),</span> <span class="n">render_value</span><span class="p">(</span><span class="n">value</span><span class="p">))</span>
            <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">context</span><span class="o">.</span><span class="n">_config</span><span class="o">.</span><span class="n">iter_config</span><span class="p">(</span><span class="n">resolve</span><span class="p">)</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">to_dict</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">resolve</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;export policy object as dictionary of options.</span>

<span class="sd">        .. deprecated:: 1.6</span>
<span class="sd">            applications should use :meth:`CryptContext.to_dict` instead.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_stub_policy</span><span class="p">:</span>
            <span class="n">warn</span><span class="p">(</span><span class="n">_preamble</span> <span class="o">+</span>
                 <span class="s2">&quot;Instead of ``context.policy.to_dict()``, &quot;</span>
                 <span class="s2">&quot;use ``context.to_dict()``.&quot;</span><span class="p">,</span>
                 <span class="ne">DeprecationWarning</span><span class="p">,</span> <span class="n">stacklevel</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">warn</span><span class="p">(</span><span class="n">_preamble</span> <span class="o">+</span>
                 <span class="s2">&quot;Instead of ``CryptPolicy().to_dict()``, &quot;</span>
                 <span class="s2">&quot;create a CryptContext instance and &quot;</span>
                 <span class="s2">&quot;use ``context.to_dict()``.&quot;</span><span class="p">,</span>
                 <span class="ne">DeprecationWarning</span><span class="p">,</span> <span class="n">stacklevel</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_context</span><span class="o">.</span><span class="n">to_dict</span><span class="p">(</span><span class="n">resolve</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">to_file</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">stream</span><span class="p">,</span> <span class="n">section</span><span class="o">=</span><span class="s2">&quot;passlib&quot;</span><span class="p">):</span> <span class="c1"># pragma: no cover -- deprecated &amp; unused</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;export policy to file.</span>

<span class="sd">        .. deprecated:: 1.6</span>
<span class="sd">            applications should use :meth:`CryptContext.to_string` instead,</span>
<span class="sd">            and then write the output to a file as desired.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_stub_policy</span><span class="p">:</span>
            <span class="n">warn</span><span class="p">(</span><span class="n">_preamble</span> <span class="o">+</span>
                 <span class="s2">&quot;Instead of ``context.policy.to_file(stream)``, &quot;</span>
                 <span class="s2">&quot;use ``stream.write(context.to_string())``.&quot;</span><span class="p">,</span>
                 <span class="ne">DeprecationWarning</span><span class="p">,</span> <span class="n">stacklevel</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">warn</span><span class="p">(</span><span class="n">_preamble</span> <span class="o">+</span>
                 <span class="s2">&quot;Instead of ``CryptPolicy().to_file(stream)``, &quot;</span>
                 <span class="s2">&quot;create a CryptContext instance and &quot;</span>
                 <span class="s2">&quot;use ``stream.write(context.to_string())``.&quot;</span><span class="p">,</span>
                 <span class="ne">DeprecationWarning</span><span class="p">,</span> <span class="n">stacklevel</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">out</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_context</span><span class="o">.</span><span class="n">to_string</span><span class="p">(</span><span class="n">section</span><span class="o">=</span><span class="n">section</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">PY2</span><span class="p">:</span>
            <span class="n">out</span> <span class="o">=</span> <span class="n">out</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="s2">&quot;utf-8&quot;</span><span class="p">)</span>
        <span class="n">stream</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">out</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">to_string</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">section</span><span class="o">=</span><span class="s2">&quot;passlib&quot;</span><span class="p">,</span> <span class="n">encoding</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;export policy to file.</span>

<span class="sd">        .. deprecated:: 1.6</span>
<span class="sd">            applications should use :meth:`CryptContext.to_string` instead.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_stub_policy</span><span class="p">:</span>
            <span class="n">warn</span><span class="p">(</span><span class="n">_preamble</span> <span class="o">+</span> <span class="c1"># pragma: no cover -- deprecated &amp; unused</span>
                 <span class="s2">&quot;Instead of ``context.policy.to_string()``, &quot;</span>
                 <span class="s2">&quot;use ``context.to_string()``.&quot;</span><span class="p">,</span>
                 <span class="ne">DeprecationWarning</span><span class="p">,</span> <span class="n">stacklevel</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">warn</span><span class="p">(</span><span class="n">_preamble</span> <span class="o">+</span>
                 <span class="s2">&quot;Instead of ``CryptPolicy().to_string()``, &quot;</span>
                 <span class="s2">&quot;create a CryptContext instance and &quot;</span>
                 <span class="s2">&quot;use ``context.to_string()``.&quot;</span><span class="p">,</span>
                 <span class="ne">DeprecationWarning</span><span class="p">,</span> <span class="n">stacklevel</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">out</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_context</span><span class="o">.</span><span class="n">to_string</span><span class="p">(</span><span class="n">section</span><span class="o">=</span><span class="n">section</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">encoding</span><span class="p">:</span>
            <span class="n">out</span> <span class="o">=</span> <span class="n">out</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="n">encoding</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">out</span>

    <span class="c1">#===================================================================</span>
    <span class="c1"># eoc</span>
    <span class="c1">#===================================================================</span>

<span class="c1">#=============================================================================</span>
<span class="c1"># _CryptConfig helper class</span>
<span class="c1">#=============================================================================</span>
<span class="k">class</span> <span class="nc">_CryptConfig</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;parses, validates, and stores CryptContext config</span>

<span class="sd">    this is a helper used internally by CryptContext to handle</span>
<span class="sd">    parsing, validation, and serialization of its config options.</span>
<span class="sd">    split out from the main class, but not made public since</span>
<span class="sd">    that just complicates interface too much (c.f. CryptPolicy)</span>

<span class="sd">    :arg source: config as dict mapping ``(cat,scheme,option) -&gt; value``</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1">#===================================================================</span>
    <span class="c1"># instance attrs</span>
    <span class="c1">#===================================================================</span>

    <span class="c1"># triple-nested dict which maps scheme -&gt; category -&gt; key -&gt; value,</span>
    <span class="c1"># storing all hash-specific options</span>
    <span class="n">_scheme_options</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="c1"># double-nested dict which maps key -&gt; category -&gt; value</span>
    <span class="c1"># storing all CryptContext options</span>
    <span class="n">_context_options</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="c1"># tuple of handler objects</span>
    <span class="n">handlers</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="c1"># tuple of scheme objects in same order as handlers</span>
    <span class="n">schemes</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="c1"># tuple of categories in alphabetical order (not including None)</span>
    <span class="n">categories</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="c1"># set of all context keywords used by active schemes</span>
    <span class="n">context_kwds</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="c1"># dict mapping category -&gt; default scheme</span>
    <span class="n">_default_schemes</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="c1"># dict mapping (scheme, category) -&gt; custom handler</span>
    <span class="n">_records</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="c1"># dict mapping category -&gt; list of custom handler instances for that category,</span>
    <span class="c1"># in order of schemes(). populated on demand by _get_record_list()</span>
    <span class="n">_record_lists</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="c1">#===================================================================</span>
    <span class="c1"># constructor</span>
    <span class="c1">#===================================================================</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">source</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_init_scheme_list</span><span class="p">(</span><span class="n">source</span><span class="o">.</span><span class="n">get</span><span class="p">((</span><span class="kc">None</span><span class="p">,</span><span class="kc">None</span><span class="p">,</span><span class="s2">&quot;schemes&quot;</span><span class="p">)))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_init_options</span><span class="p">(</span><span class="n">source</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_init_default_schemes</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_init_records</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">_init_scheme_list</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;initialize .handlers and .schemes attributes&quot;&quot;&quot;</span>
        <span class="n">handlers</span>  <span class="o">=</span> <span class="p">[]</span>
        <span class="n">schemes</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">native_string_types</span><span class="p">):</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">splitcomma</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">elem</span> <span class="ow">in</span> <span class="n">data</span> <span class="ow">or</span> <span class="p">():</span>
            <span class="c1"># resolve elem -&gt; handler &amp; scheme</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">elem</span><span class="p">,</span> <span class="s2">&quot;name&quot;</span><span class="p">):</span>
                <span class="n">handler</span> <span class="o">=</span> <span class="n">elem</span>
                <span class="n">scheme</span> <span class="o">=</span> <span class="n">handler</span><span class="o">.</span><span class="n">name</span>
                <span class="n">_validate_handler_name</span><span class="p">(</span><span class="n">scheme</span><span class="p">)</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">elem</span><span class="p">,</span> <span class="n">native_string_types</span><span class="p">):</span>
                <span class="n">handler</span> <span class="o">=</span> <span class="n">get_crypt_handler</span><span class="p">(</span><span class="n">elem</span><span class="p">)</span>
                <span class="n">scheme</span> <span class="o">=</span> <span class="n">handler</span><span class="o">.</span><span class="n">name</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;scheme must be name or CryptHandler, &quot;</span>
                                <span class="s2">&quot;not </span><span class="si">%r</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="nb">type</span><span class="p">(</span><span class="n">elem</span><span class="p">))</span>

            <span class="c1"># check scheme name isn&#39;t already in use</span>
            <span class="k">if</span> <span class="n">scheme</span> <span class="ow">in</span> <span class="n">schemes</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="s2">&quot;multiple handlers with same name: </span><span class="si">%r</span><span class="s2">&quot;</span> <span class="o">%</span>
                               <span class="p">(</span><span class="n">scheme</span><span class="p">,))</span>

            <span class="c1"># add to handler list</span>
            <span class="n">handlers</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">handler</span><span class="p">)</span>
            <span class="n">schemes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">scheme</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">handlers</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">handlers</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">schemes</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">schemes</span><span class="p">)</span>

    <span class="c1">#===================================================================</span>
    <span class="c1"># lowlevel options</span>
    <span class="c1">#===================================================================</span>

    <span class="c1">#---------------------------------------------------------------</span>
    <span class="c1"># init lowlevel option storage</span>
    <span class="c1">#---------------------------------------------------------------</span>
    <span class="k">def</span> <span class="nf">_init_options</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">source</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;load config dict into internal representation,</span>
<span class="sd">        and init .categories attr</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># prepare dicts &amp; locals</span>
        <span class="n">norm_scheme_option</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_norm_scheme_option</span>
        <span class="n">norm_context_option</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_norm_context_option</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_scheme_options</span> <span class="o">=</span> <span class="n">scheme_options</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_context_options</span> <span class="o">=</span> <span class="n">context_options</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">categories</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>

        <span class="c1"># load source config into internal storage</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">cat</span><span class="p">,</span> <span class="n">scheme</span><span class="p">,</span> <span class="n">key</span><span class="p">),</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">iteritems</span><span class="p">(</span><span class="n">source</span><span class="p">):</span>
            <span class="n">categories</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">cat</span><span class="p">)</span>
            <span class="n">explicit_scheme</span> <span class="o">=</span> <span class="n">scheme</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">cat</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">scheme</span> <span class="ow">and</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">_global_settings</span><span class="p">:</span>
                <span class="c1"># going forward, not using &quot;&lt;cat&gt;__all__&lt;key&gt;&quot; format. instead...</span>
                <span class="c1"># whitelisting set of keys which should be passed to (all) schemes,</span>
                <span class="c1"># rather than passed to the CryptContext itself</span>
                <span class="n">scheme</span> <span class="o">=</span> <span class="s2">&quot;all&quot;</span>
            <span class="k">if</span> <span class="n">scheme</span><span class="p">:</span>
                <span class="c1"># normalize scheme option</span>
                <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="o">=</span> <span class="n">norm_scheme_option</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>

                <span class="c1"># e.g. things like &quot;min_rounds&quot; should never be set cross-scheme</span>
                <span class="c1"># this will be fatal under 2.0.</span>
                <span class="k">if</span> <span class="n">scheme</span> <span class="o">==</span> <span class="s2">&quot;all&quot;</span> <span class="ow">and</span> <span class="n">key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">_global_settings</span><span class="p">:</span>
                    <span class="n">warn</span><span class="p">(</span><span class="s2">&quot;The &#39;</span><span class="si">%s</span><span class="s2">&#39; option should be configured per-algorithm, and not set &quot;</span>
                         <span class="s2">&quot;globally in the context; This will be an error in Passlib 2.0&quot;</span> <span class="o">%</span>
                         <span class="p">(</span><span class="n">key</span><span class="p">,),</span> <span class="n">PasslibConfigWarning</span><span class="p">)</span>

                <span class="c1"># this scheme is going away in 2.0;</span>
                <span class="c1"># but most keys deserve an extra warning since it impacts security.</span>
                <span class="k">if</span> <span class="n">explicit_scheme</span> <span class="o">==</span> <span class="s2">&quot;all&quot;</span><span class="p">:</span>
                    <span class="n">warn</span><span class="p">(</span><span class="s2">&quot;The &#39;all&#39; scheme is deprecated as of Passlib 1.7, &quot;</span>
                         <span class="s2">&quot;and will be removed in Passlib 2.0; Please configure &quot;</span>
                         <span class="s2">&quot;options on a per-algorithm basis.&quot;</span><span class="p">,</span> <span class="ne">DeprecationWarning</span><span class="p">)</span>

                <span class="c1"># store in scheme_options</span>
                <span class="c1"># map structure: scheme_options[scheme][category][key] = value</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">category_map</span> <span class="o">=</span> <span class="n">scheme_options</span><span class="p">[</span><span class="n">scheme</span><span class="p">]</span>
                <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                    <span class="n">scheme_options</span><span class="p">[</span><span class="n">scheme</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="n">cat</span><span class="p">:</span> <span class="p">{</span><span class="n">key</span><span class="p">:</span> <span class="n">value</span><span class="p">}}</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="n">option_map</span> <span class="o">=</span> <span class="n">category_map</span><span class="p">[</span><span class="n">cat</span><span class="p">]</span>
                    <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                        <span class="n">category_map</span><span class="p">[</span><span class="n">cat</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="n">key</span><span class="p">:</span> <span class="n">value</span><span class="p">}</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">option_map</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># normalize context option</span>
                <span class="k">if</span> <span class="n">cat</span> <span class="ow">and</span> <span class="n">key</span> <span class="o">==</span> <span class="s2">&quot;schemes&quot;</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="s2">&quot;&#39;schemes&#39; context option is not allowed &quot;</span>
                                   <span class="s2">&quot;per category&quot;</span><span class="p">)</span>
                <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="o">=</span> <span class="n">norm_context_option</span><span class="p">(</span><span class="n">cat</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">key</span> <span class="o">==</span> <span class="s2">&quot;min_verify_time&quot;</span><span class="p">:</span> <span class="c1"># ignored in 1.7, to be removed in 1.8</span>
                    <span class="k">continue</span>

                <span class="c1"># store in context_options</span>
                <span class="c1"># map structure: context_options[key][category] = value</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">category_map</span> <span class="o">=</span> <span class="n">context_options</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
                <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                    <span class="n">context_options</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="n">cat</span><span class="p">:</span> <span class="n">value</span><span class="p">}</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">category_map</span><span class="p">[</span><span class="n">cat</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>

        <span class="c1"># store list of configured categories</span>
        <span class="n">categories</span><span class="o">.</span><span class="n">discard</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">categories</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="n">categories</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">_norm_scheme_option</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="c1"># check for invalid options</span>
        <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">_forbidden_scheme_options</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%r</span><span class="s2"> option not allowed in CryptContext &quot;</span>
                           <span class="s2">&quot;configuration&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">key</span><span class="p">,))</span>
        <span class="c1"># coerce strings for certain fields (e.g. min_rounds uses ints)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">native_string_types</span><span class="p">):</span>
            <span class="n">func</span> <span class="o">=</span> <span class="n">_coerce_scheme_options</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">func</span><span class="p">:</span>
                <span class="n">value</span> <span class="o">=</span> <span class="n">func</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span>

    <span class="k">def</span> <span class="nf">_norm_context_option</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cat</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="n">schemes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">schemes</span>
        <span class="k">if</span> <span class="n">key</span> <span class="o">==</span> <span class="s2">&quot;default&quot;</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="s2">&quot;name&quot;</span><span class="p">):</span>
                <span class="n">value</span> <span class="o">=</span> <span class="n">value</span><span class="o">.</span><span class="n">name</span>
            <span class="k">elif</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">native_string_types</span><span class="p">):</span>
                <span class="k">raise</span> <span class="n">ExpectedTypeError</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="s2">&quot;str&quot;</span><span class="p">,</span> <span class="s2">&quot;default&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">schemes</span> <span class="ow">and</span> <span class="n">value</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">schemes</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="s2">&quot;default scheme not found in policy&quot;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">key</span> <span class="o">==</span> <span class="s2">&quot;deprecated&quot;</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">native_string_types</span><span class="p">):</span>
                <span class="n">value</span> <span class="o">=</span> <span class="n">splitcomma</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
            <span class="k">elif</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span><span class="nb">tuple</span><span class="p">)):</span>
                <span class="k">raise</span> <span class="n">ExpectedTypeError</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="s2">&quot;str or seq&quot;</span><span class="p">,</span> <span class="s2">&quot;deprecated&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="s1">&#39;auto&#39;</span> <span class="ow">in</span> <span class="n">value</span><span class="p">:</span>
                <span class="c1"># XXX: have any statements been made about when this is default?</span>
                <span class="c1">#      should do it in 1.8 at latest.</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;cannot list other schemes if &quot;</span>
                                     <span class="s2">&quot;``deprecated=[&#39;auto&#39;]`` is used&quot;</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">schemes</span><span class="p">:</span>
                <span class="c1"># make sure list of deprecated schemes is subset of configured schemes</span>
                <span class="k">for</span> <span class="n">scheme</span> <span class="ow">in</span> <span class="n">value</span><span class="p">:</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">scheme</span><span class="p">,</span> <span class="n">native_string_types</span><span class="p">):</span>
                        <span class="k">raise</span> <span class="n">ExpectedTypeError</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="s2">&quot;str&quot;</span><span class="p">,</span> <span class="s2">&quot;deprecated element&quot;</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">scheme</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">schemes</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="s2">&quot;deprecated scheme not found &quot;</span>
                                   <span class="s2">&quot;in policy: </span><span class="si">%r</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">scheme</span><span class="p">,))</span>
        <span class="k">elif</span> <span class="n">key</span> <span class="o">==</span> <span class="s2">&quot;min_verify_time&quot;</span><span class="p">:</span>
            <span class="n">warn</span><span class="p">(</span><span class="s2">&quot;&#39;min_verify_time&#39; was deprecated in Passlib 1.6, is &quot;</span>
                 <span class="s2">&quot;ignored in 1.7, and will be removed in 1.8&quot;</span><span class="p">,</span>
                 <span class="ne">DeprecationWarning</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">key</span> <span class="o">==</span> <span class="s2">&quot;harden_verify&quot;</span><span class="p">:</span>
            <span class="n">warn</span><span class="p">(</span><span class="s2">&quot;&#39;harden_verify&#39; is deprecated &amp; ignored as of Passlib 1.7.1, &quot;</span>
                 <span class="s2">&quot; and will be removed in 1.8&quot;</span><span class="p">,</span>
                 <span class="ne">DeprecationWarning</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">key</span> <span class="o">!=</span> <span class="s2">&quot;schemes&quot;</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="s2">&quot;unknown CryptContext keyword: </span><span class="si">%r</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">key</span><span class="p">,))</span>
        <span class="k">return</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span>

    <span class="c1">#---------------------------------------------------------------</span>
    <span class="c1"># reading context options</span>
    <span class="c1">#---------------------------------------------------------------</span>
    <span class="k">def</span> <span class="nf">get_context_optionmap</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">_default</span><span class="o">=</span><span class="p">{}):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;return dict mapping category-&gt;value for specific context option.</span>

<span class="sd">        .. warning:: treat return value as readonly!</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_context_options</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">_default</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">get_context_option_with_flag</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">category</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;return value of specific option, handling category inheritance.</span>
<span class="sd">        also returns flag indicating whether value is category-specific.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">category_map</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_context_options</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">False</span>
        <span class="n">value</span> <span class="o">=</span> <span class="n">category_map</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">category</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">alt</span> <span class="o">=</span> <span class="n">category_map</span><span class="p">[</span><span class="n">category</span><span class="p">]</span>
            <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                <span class="k">pass</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">value</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">alt</span> <span class="o">!=</span> <span class="n">value</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">alt</span><span class="p">,</span> <span class="kc">True</span>
        <span class="k">return</span> <span class="n">value</span><span class="p">,</span> <span class="kc">False</span>

    <span class="c1">#---------------------------------------------------------------</span>
    <span class="c1"># reading scheme options</span>
    <span class="c1">#---------------------------------------------------------------</span>
    <span class="k">def</span> <span class="nf">_get_scheme_optionmap</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">scheme</span><span class="p">,</span> <span class="n">category</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="p">{}):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;return all options for (scheme,category) combination</span>

<span class="sd">        .. warning:: treat return value as readonly!</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_scheme_options</span><span class="p">[</span><span class="n">scheme</span><span class="p">][</span><span class="n">category</span><span class="p">]</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">default</span>

    <span class="k">def</span> <span class="nf">get_base_handler</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">scheme</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">handlers</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">schemes</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">scheme</span><span class="p">)]</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">expand_settings</span><span class="p">(</span><span class="n">handler</span><span class="p">):</span>
        <span class="n">setting_kwds</span> <span class="o">=</span> <span class="n">handler</span><span class="o">.</span><span class="n">setting_kwds</span>
        <span class="k">if</span> <span class="s1">&#39;rounds&#39;</span> <span class="ow">in</span> <span class="n">handler</span><span class="o">.</span><span class="n">setting_kwds</span><span class="p">:</span>
            <span class="c1"># XXX: historically this extras won&#39;t be listed in setting_kwds</span>
            <span class="n">setting_kwds</span> <span class="o">+=</span> <span class="n">uh</span><span class="o">.</span><span class="n">HasRounds</span><span class="o">.</span><span class="n">using_rounds_kwds</span>
        <span class="k">return</span> <span class="n">setting_kwds</span>

    <span class="c1"># NOTE: this is only used by _get_record_options_with_flag()...</span>
    <span class="k">def</span> <span class="nf">get_scheme_options_with_flag</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">scheme</span><span class="p">,</span> <span class="n">category</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;return composite dict of all options set for scheme.</span>
<span class="sd">        includes options inherited from &#39;all&#39; and from default category.</span>
<span class="sd">        result can be modified.</span>
<span class="sd">        returns (kwds, has_cat_specific_options)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># start out with copy of global options</span>
        <span class="n">get_optionmap</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_scheme_optionmap</span>
        <span class="n">kwds</span> <span class="o">=</span> <span class="n">get_optionmap</span><span class="p">(</span><span class="s2">&quot;all&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">has_cat_options</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="c1"># add in category-specific global options</span>
        <span class="k">if</span> <span class="n">category</span><span class="p">:</span>
            <span class="n">defkwds</span> <span class="o">=</span> <span class="n">kwds</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span> <span class="c1"># &lt;-- used to detect category-specific options</span>
            <span class="n">kwds</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">get_optionmap</span><span class="p">(</span><span class="s2">&quot;all&quot;</span><span class="p">,</span> <span class="n">category</span><span class="p">))</span>

        <span class="c1"># filter out global settings not supported by handler</span>
        <span class="n">allowed_settings</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">expand_settings</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_base_handler</span><span class="p">(</span><span class="n">scheme</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="nb">set</span><span class="p">(</span><span class="n">kwds</span><span class="p">)</span><span class="o">.</span><span class="n">difference</span><span class="p">(</span><span class="n">allowed_settings</span><span class="p">):</span>
            <span class="n">kwds</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">category</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="nb">set</span><span class="p">(</span><span class="n">defkwds</span><span class="p">)</span><span class="o">.</span><span class="n">difference</span><span class="p">(</span><span class="n">allowed_settings</span><span class="p">):</span>
                <span class="n">defkwds</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>

        <span class="c1"># add in default options for scheme</span>
        <span class="n">other</span> <span class="o">=</span> <span class="n">get_optionmap</span><span class="p">(</span><span class="n">scheme</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="n">kwds</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>

        <span class="c1"># load category-specific options for scheme</span>
        <span class="k">if</span> <span class="n">category</span><span class="p">:</span>
            <span class="n">defkwds</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
            <span class="n">kwds</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">get_optionmap</span><span class="p">(</span><span class="n">scheme</span><span class="p">,</span> <span class="n">category</span><span class="p">))</span>

            <span class="c1"># compare default category options to see if there&#39;s anything</span>
            <span class="c1"># category-specific</span>
            <span class="k">if</span> <span class="n">kwds</span> <span class="o">!=</span> <span class="n">defkwds</span><span class="p">:</span>
                <span class="n">has_cat_options</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="k">return</span> <span class="n">kwds</span><span class="p">,</span> <span class="n">has_cat_options</span>

    <span class="c1">#===================================================================</span>
    <span class="c1"># deprecated &amp; default schemes</span>
    <span class="c1">#===================================================================</span>
    <span class="k">def</span> <span class="nf">_init_default_schemes</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;initialize maps containing default scheme for each category.</span>

<span class="sd">        have to do this after _init_options(), since the default scheme</span>
<span class="sd">        is affected by the list of deprecated schemes.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># init maps &amp; locals</span>
        <span class="n">get_optionmap</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_context_optionmap</span>
        <span class="n">default_map</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_default_schemes</span> <span class="o">=</span> <span class="n">get_optionmap</span><span class="p">(</span><span class="s2">&quot;default&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">dep_map</span> <span class="o">=</span> <span class="n">get_optionmap</span><span class="p">(</span><span class="s2">&quot;deprecated&quot;</span><span class="p">)</span>
        <span class="n">schemes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">schemes</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">schemes</span><span class="p">:</span>
            <span class="k">return</span>

        <span class="c1"># figure out default scheme</span>
        <span class="n">deps</span> <span class="o">=</span> <span class="n">dep_map</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span> <span class="ow">or</span> <span class="p">()</span>
        <span class="n">default</span> <span class="o">=</span> <span class="n">default_map</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">default</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">scheme</span> <span class="ow">in</span> <span class="n">schemes</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">scheme</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">deps</span><span class="p">:</span>
                    <span class="n">default_map</span><span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">=</span> <span class="n">scheme</span>
                    <span class="k">break</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;must have at least one non-deprecated scheme&quot;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">default</span> <span class="ow">in</span> <span class="n">deps</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;default scheme cannot be deprecated&quot;</span><span class="p">)</span>

        <span class="c1"># figure out per-category default schemes,</span>
        <span class="k">for</span> <span class="n">cat</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">categories</span><span class="p">:</span>
            <span class="n">cdeps</span> <span class="o">=</span> <span class="n">dep_map</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">cat</span><span class="p">,</span> <span class="n">deps</span><span class="p">)</span>
            <span class="n">cdefault</span> <span class="o">=</span> <span class="n">default_map</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">cat</span><span class="p">,</span> <span class="n">default</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">cdefault</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">scheme</span> <span class="ow">in</span> <span class="n">schemes</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">scheme</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">cdeps</span><span class="p">:</span>
                        <span class="n">default_map</span><span class="p">[</span><span class="n">cat</span><span class="p">]</span> <span class="o">=</span> <span class="n">scheme</span>
                        <span class="k">break</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;must have at least one non-deprecated &quot;</span>
                                     <span class="s2">&quot;scheme for </span><span class="si">%r</span><span class="s2"> category&quot;</span> <span class="o">%</span> <span class="n">cat</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">cdefault</span> <span class="ow">in</span> <span class="n">cdeps</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;default scheme for </span><span class="si">%r</span><span class="s2"> category &quot;</span>
                                 <span class="s2">&quot;cannot be deprecated&quot;</span> <span class="o">%</span> <span class="n">cat</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">default_scheme</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">category</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;return default scheme for specific category&quot;&quot;&quot;</span>
        <span class="n">defaults</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_default_schemes</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">defaults</span><span class="p">[</span><span class="n">category</span><span class="p">]</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="k">pass</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">schemes</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="s2">&quot;no hash schemes configured for this &quot;</span>
                           <span class="s2">&quot;CryptContext instance&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">defaults</span><span class="p">[</span><span class="kc">None</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">is_deprecated_with_flag</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">scheme</span><span class="p">,</span> <span class="n">category</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;is scheme deprecated under particular category?&quot;&quot;&quot;</span>
        <span class="n">depmap</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_context_optionmap</span><span class="p">(</span><span class="s2">&quot;deprecated&quot;</span><span class="p">)</span>
        <span class="k">def</span> <span class="nf">test</span><span class="p">(</span><span class="n">cat</span><span class="p">):</span>
            <span class="n">source</span> <span class="o">=</span> <span class="n">depmap</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">cat</span><span class="p">,</span> <span class="n">depmap</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="kc">None</span><span class="p">))</span>
            <span class="k">if</span> <span class="n">source</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">None</span>
            <span class="k">elif</span> <span class="s1">&#39;auto&#39;</span> <span class="ow">in</span> <span class="n">source</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">scheme</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">default_scheme</span><span class="p">(</span><span class="n">cat</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">scheme</span> <span class="ow">in</span> <span class="n">source</span>
        <span class="n">value</span> <span class="o">=</span> <span class="n">test</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span> <span class="ow">or</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="n">category</span><span class="p">:</span>
            <span class="n">alt</span> <span class="o">=</span> <span class="n">test</span><span class="p">(</span><span class="n">category</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">alt</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">value</span> <span class="o">!=</span> <span class="n">alt</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">alt</span><span class="p">,</span> <span class="kc">True</span>
        <span class="k">return</span> <span class="n">value</span><span class="p">,</span> <span class="kc">False</span>

    <span class="c1">#===================================================================</span>
    <span class="c1"># CryptRecord objects</span>
    <span class="c1">#===================================================================</span>
    <span class="k">def</span> <span class="nf">_init_records</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># NOTE: this step handles final validation of settings,</span>
        <span class="c1">#       checking for violations against handler&#39;s internal invariants.</span>
        <span class="c1">#       this is why we create all the records now,</span>
        <span class="c1">#       so CryptContext throws error immediately rather than later.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_record_lists</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">records</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_records</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">all_context_kwds</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">context_kwds</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="n">get_options</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_record_options_with_flag</span>
        <span class="n">categories</span> <span class="o">=</span> <span class="p">(</span><span class="kc">None</span><span class="p">,)</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">categories</span>
        <span class="k">for</span> <span class="n">handler</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">handlers</span><span class="p">:</span>
            <span class="n">scheme</span> <span class="o">=</span> <span class="n">handler</span><span class="o">.</span><span class="n">name</span>
            <span class="n">all_context_kwds</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">handler</span><span class="o">.</span><span class="n">context_kwds</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">cat</span> <span class="ow">in</span> <span class="n">categories</span><span class="p">:</span>
                <span class="n">kwds</span><span class="p">,</span> <span class="n">has_cat_options</span> <span class="o">=</span> <span class="n">get_options</span><span class="p">(</span><span class="n">scheme</span><span class="p">,</span> <span class="n">cat</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">cat</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">has_cat_options</span><span class="p">:</span>
                    <span class="n">records</span><span class="p">[</span><span class="n">scheme</span><span class="p">,</span> <span class="n">cat</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_create_record</span><span class="p">(</span><span class="n">handler</span><span class="p">,</span> <span class="n">cat</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">)</span>
                <span class="c1"># NOTE: if handler has no category-specific opts, get_record()</span>
                <span class="c1"># will automatically use the default category&#39;s record.</span>
        <span class="c1"># NOTE: default records for specific category stored under the</span>
        <span class="c1"># key (None,category); these are populated on-demand by get_record().</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_create_record</span><span class="p">(</span><span class="n">handler</span><span class="p">,</span> <span class="n">category</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">deprecated</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">settings</span><span class="p">):</span>
        <span class="c1"># create custom handler if needed.</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="c1"># XXX: relaxed=True is mostly here to retain backwards-compat behavior.</span>
            <span class="c1">#      could make this optional flag in future.</span>
            <span class="n">subcls</span> <span class="o">=</span> <span class="n">handler</span><span class="o">.</span><span class="n">using</span><span class="p">(</span><span class="n">relaxed</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">settings</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">TypeError</span> <span class="k">as</span> <span class="n">err</span><span class="p">:</span>
            <span class="n">m</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;.* unexpected keyword argument &#39;(.*)&#39;$&quot;</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">err</span><span class="p">))</span>
            <span class="k">if</span> <span class="n">m</span> <span class="ow">and</span> <span class="n">m</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="ow">in</span> <span class="n">settings</span><span class="p">:</span>
                <span class="c1"># translate into KeyError, for backwards compat.</span>
                <span class="c1"># XXX: push this down to GenericHandler.using() implementation?</span>
                <span class="n">key</span> <span class="o">=</span> <span class="n">m</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
                <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="s2">&quot;keyword not supported by </span><span class="si">%s</span><span class="s2"> handler: </span><span class="si">%r</span><span class="s2">&quot;</span> <span class="o">%</span>
                               <span class="p">(</span><span class="n">handler</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">key</span><span class="p">))</span>
            <span class="k">raise</span>

        <span class="c1"># using private attrs to store some extra metadata in custom handler</span>
        <span class="k">assert</span> <span class="n">subcls</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">handler</span><span class="p">,</span> <span class="s2">&quot;expected unique variant of handler&quot;</span>
        <span class="c1">##subcls._Context__category = category</span>
        <span class="n">subcls</span><span class="o">.</span><span class="n">_Context__orig_handler</span> <span class="o">=</span> <span class="n">handler</span>
        <span class="n">subcls</span><span class="o">.</span><span class="n">deprecated</span> <span class="o">=</span> <span class="n">deprecated</span>  <span class="c1"># attr reserved for this purpose</span>
        <span class="k">return</span> <span class="n">subcls</span>

    <span class="k">def</span> <span class="nf">_get_record_options_with_flag</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">scheme</span><span class="p">,</span> <span class="n">category</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;return composite dict of options for given scheme + category.</span>

<span class="sd">        this is currently a private method, though some variant</span>
<span class="sd">        of its output may eventually be made public.</span>

<span class="sd">        given a scheme &amp; category, it returns two things:</span>
<span class="sd">        a set of all the keyword options to pass to :meth:`_create_record`,</span>
<span class="sd">        and a bool flag indicating whether any of these options</span>
<span class="sd">        were specific to the named category. if this flag is false,</span>
<span class="sd">        the options are identical to the options for the default category.</span>

<span class="sd">        the options dict includes all the scheme-specific settings,</span>
<span class="sd">        as well as optional *deprecated* keyword.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># get scheme options</span>
        <span class="n">kwds</span><span class="p">,</span> <span class="n">has_cat_options</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_scheme_options_with_flag</span><span class="p">(</span><span class="n">scheme</span><span class="p">,</span> <span class="n">category</span><span class="p">)</span>

        <span class="c1"># throw in deprecated flag</span>
        <span class="n">value</span><span class="p">,</span> <span class="n">not_inherited</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_deprecated_with_flag</span><span class="p">(</span><span class="n">scheme</span><span class="p">,</span> <span class="n">category</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">value</span><span class="p">:</span>
            <span class="n">kwds</span><span class="p">[</span><span class="s1">&#39;deprecated&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">if</span> <span class="n">not_inherited</span><span class="p">:</span>
            <span class="n">has_cat_options</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="k">return</span> <span class="n">kwds</span><span class="p">,</span> <span class="n">has_cat_options</span>

    <span class="k">def</span> <span class="nf">get_record</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">scheme</span><span class="p">,</span> <span class="n">category</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;return record for specific scheme &amp; category (cached)&quot;&quot;&quot;</span>
        <span class="c1"># NOTE: this is part of the critical path shared by</span>
        <span class="c1">#       all of CryptContext&#39;s PasswordHash methods,</span>
        <span class="c1">#       hence all the caching and error checking.</span>

        <span class="c1"># quick lookup in cache</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_records</span><span class="p">[</span><span class="n">scheme</span><span class="p">,</span> <span class="n">category</span><span class="p">]</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="k">pass</span>

        <span class="c1"># type check</span>
        <span class="k">if</span> <span class="n">category</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">category</span><span class="p">,</span> <span class="n">native_string_types</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">PY2</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">category</span><span class="p">,</span> <span class="n">unicode</span><span class="p">):</span>
                <span class="c1"># for compatibility with unicode-centric py2 apps</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_record</span><span class="p">(</span><span class="n">scheme</span><span class="p">,</span> <span class="n">category</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="s2">&quot;utf-8&quot;</span><span class="p">))</span>
            <span class="k">raise</span> <span class="n">ExpectedTypeError</span><span class="p">(</span><span class="n">category</span><span class="p">,</span> <span class="s2">&quot;str or None&quot;</span><span class="p">,</span> <span class="s2">&quot;category&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">scheme</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">scheme</span><span class="p">,</span> <span class="n">native_string_types</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">ExpectedTypeError</span><span class="p">(</span><span class="n">scheme</span><span class="p">,</span> <span class="s2">&quot;str or None&quot;</span><span class="p">,</span> <span class="s2">&quot;scheme&quot;</span><span class="p">)</span>

        <span class="c1"># if scheme=None,</span>
        <span class="c1"># use record for category&#39;s default scheme, and cache result.</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">scheme</span><span class="p">:</span>
            <span class="n">default</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">default_scheme</span><span class="p">(</span><span class="n">category</span><span class="p">)</span>
            <span class="k">assert</span> <span class="n">default</span>
            <span class="n">record</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_records</span><span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="n">category</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_record</span><span class="p">(</span><span class="n">default</span><span class="p">,</span>
                                                                      <span class="n">category</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">record</span>

        <span class="c1"># if no record for (scheme, category),</span>
        <span class="c1"># use record for (scheme, None), and cache result.</span>
        <span class="k">if</span> <span class="n">category</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">cache</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_records</span>
                <span class="n">record</span> <span class="o">=</span> <span class="n">cache</span><span class="p">[</span><span class="n">scheme</span><span class="p">,</span> <span class="n">category</span><span class="p">]</span> <span class="o">=</span> <span class="n">cache</span><span class="p">[</span><span class="n">scheme</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span>
                <span class="k">return</span> <span class="n">record</span>
            <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                <span class="k">pass</span>

        <span class="c1"># scheme not found in configuration for default category</span>
        <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="s2">&quot;crypt algorithm not found in policy: </span><span class="si">%r</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">scheme</span><span class="p">,))</span>

    <span class="k">def</span> <span class="nf">_get_record_list</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">category</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;return list of records for category (cached)</span>

<span class="sd">        this is an internal helper used only by identify_record()</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># type check of category - handled by _get_record()</span>
        <span class="c1"># quick lookup in cache</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_record_lists</span><span class="p">[</span><span class="n">category</span><span class="p">]</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="k">pass</span>
        <span class="c1"># cache miss - build list from scratch</span>
        <span class="n">value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_record_lists</span><span class="p">[</span><span class="n">category</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">get_record</span><span class="p">(</span><span class="n">scheme</span><span class="p">,</span> <span class="n">category</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">scheme</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">schemes</span>
            <span class="p">]</span>
        <span class="k">return</span> <span class="n">value</span>

    <span class="k">def</span> <span class="nf">identify_record</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">hash</span><span class="p">,</span> <span class="n">category</span><span class="p">,</span> <span class="n">required</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;internal helper to identify appropriate custom handler for hash&quot;&quot;&quot;</span>
        <span class="c1"># NOTE: this is part of the critical path shared by</span>
        <span class="c1">#       all of CryptContext&#39;s PasswordHash methods,</span>
        <span class="c1">#       hence all the caching and error checking.</span>
        <span class="c1"># FIXME: if multiple hashes could match (e.g. lmhash vs nthash)</span>
        <span class="c1">#        this will only return first match. might want to do something</span>
        <span class="c1">#        about this in future, but for now only hashes with</span>
        <span class="c1">#        unique identifiers will work properly in a CryptContext.</span>
        <span class="c1"># XXX: if all handlers have a unique prefix (e.g. all are MCF / LDAP),</span>
        <span class="c1">#      could use dict-lookup to speed up this search.</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="nb">hash</span><span class="p">,</span> <span class="n">unicode_or_bytes_types</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">ExpectedStringError</span><span class="p">(</span><span class="nb">hash</span><span class="p">,</span> <span class="s2">&quot;hash&quot;</span><span class="p">)</span>
        <span class="c1"># type check of category - handled by _get_record_list()</span>
        <span class="k">for</span> <span class="n">record</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_record_list</span><span class="p">(</span><span class="n">category</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">record</span><span class="o">.</span><span class="n">identify</span><span class="p">(</span><span class="nb">hash</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">record</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">required</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">schemes</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="s2">&quot;no crypt algorithms supported&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">exc</span><span class="o">.</span><span class="n">UnknownHashError</span><span class="p">(</span><span class="s2">&quot;hash could not be identified&quot;</span><span class="p">)</span>

    <span class="nd">@memoized_property</span>
    <span class="k">def</span> <span class="nf">disabled_record</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">record</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_record_list</span><span class="p">(</span><span class="kc">None</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">record</span><span class="o">.</span><span class="n">is_disabled</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">record</span>
        <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;no disabled hasher present &quot;</span>
                           <span class="s2">&quot;(perhaps add &#39;unix_disabled&#39; to list of schemes?)&quot;</span><span class="p">)</span>

    <span class="c1">#===================================================================</span>
    <span class="c1"># serialization</span>
    <span class="c1">#===================================================================</span>
    <span class="k">def</span> <span class="nf">iter_config</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">resolve</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;regenerate original config.</span>

<span class="sd">        this is an iterator which yields ``(cat,scheme,option),value`` items,</span>
<span class="sd">        in the order they generally appear inside an INI file.</span>
<span class="sd">        if interpreted as a dictionary, it should match the original</span>
<span class="sd">        keywords passed to the CryptContext (aside from any canonization).</span>

<span class="sd">        it&#39;s mainly used as the internal backend for most of the public</span>
<span class="sd">        serialization methods.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># grab various bits of data</span>
        <span class="n">scheme_options</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_scheme_options</span>
        <span class="n">context_options</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_context_options</span>
        <span class="n">scheme_keys</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">scheme_options</span><span class="p">)</span>
        <span class="n">context_keys</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">context_options</span><span class="p">)</span>

        <span class="c1"># write loaded schemes (may differ from &#39;schemes&#39; local var)</span>
        <span class="k">if</span> <span class="s1">&#39;schemes&#39;</span> <span class="ow">in</span> <span class="n">context_keys</span><span class="p">:</span>
            <span class="n">context_keys</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="s2">&quot;schemes&quot;</span><span class="p">)</span>
        <span class="n">value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">handlers</span> <span class="k">if</span> <span class="n">resolve</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">schemes</span>
        <span class="k">if</span> <span class="n">value</span><span class="p">:</span>
            <span class="k">yield</span> <span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="s2">&quot;schemes&quot;</span><span class="p">),</span> <span class="nb">list</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>

        <span class="c1"># then run through config for each user category</span>
        <span class="k">for</span> <span class="n">cat</span> <span class="ow">in</span> <span class="p">(</span><span class="kc">None</span><span class="p">,)</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">categories</span><span class="p">:</span>

            <span class="c1"># write context options</span>
            <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">context_keys</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">value</span> <span class="o">=</span> <span class="n">context_options</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="n">cat</span><span class="p">]</span>
                <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                    <span class="k">pass</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
                        <span class="n">value</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
                    <span class="k">yield</span> <span class="p">(</span><span class="n">cat</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="n">key</span><span class="p">),</span> <span class="n">value</span>

            <span class="c1"># write per-scheme options for all schemes.</span>
            <span class="k">for</span> <span class="n">scheme</span> <span class="ow">in</span> <span class="n">scheme_keys</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">kwds</span> <span class="o">=</span> <span class="n">scheme_options</span><span class="p">[</span><span class="n">scheme</span><span class="p">][</span><span class="n">cat</span><span class="p">]</span>
                <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                    <span class="k">pass</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">kwds</span><span class="p">):</span>
                        <span class="k">yield</span> <span class="p">(</span><span class="n">cat</span><span class="p">,</span> <span class="n">scheme</span><span class="p">,</span> <span class="n">key</span><span class="p">),</span> <span class="n">kwds</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>

    <span class="c1">#===================================================================</span>
    <span class="c1"># eoc</span>
    <span class="c1">#===================================================================</span>

<span class="c1">#=============================================================================</span>
<span class="c1"># main CryptContext class</span>
<span class="c1">#=============================================================================</span>
<span class="k">class</span> <span class="nc">CryptContext</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Helper for hashing &amp; verifying passwords using multiple algorithms.</span>

<span class="sd">    Instances of this class allow applications to choose a specific</span>
<span class="sd">    set of hash algorithms which they wish to support, set limits and defaults</span>
<span class="sd">    for the rounds and salt sizes those algorithms should use, flag</span>
<span class="sd">    which algorithms should be deprecated, and automatically handle</span>
<span class="sd">    migrating users to stronger hashes when they log in.</span>

<span class="sd">    Basic usage::</span>

<span class="sd">        &gt;&gt;&gt; ctx = CryptContext(schemes=[...])</span>

<span class="sd">    See the Passlib online documentation for details and full documentation.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># FIXME: altering the configuration of this object isn&#39;t threadsafe,</span>
    <span class="c1"># but is generally only done during application init, so not a major</span>
    <span class="c1"># issue (just yet).</span>

    <span class="c1"># XXX: would like some way to restrict the categories that are allowed,</span>
    <span class="c1"># to restrict what the app OR the config can use.</span>

    <span class="c1"># XXX: add wrap/unwrap callback hooks so app can mutate hash format?</span>

    <span class="c1"># XXX: add method for detecting and warning user about schemes</span>
    <span class="c1">#      which don&#39;t have any good distinguishing marks?</span>
    <span class="c1">#      or greedy ones (unix_disabled, plaintext) which are not listed at the end?</span>

    <span class="c1">#===================================================================</span>
    <span class="c1"># instance attrs</span>
    <span class="c1">#===================================================================</span>

    <span class="c1"># _CryptConfig instance holding current parsed config</span>
    <span class="n">_config</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="c1"># copy of _config methods, stored in CryptContext instance for speed.</span>
    <span class="n">_get_record</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">_identify_record</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="c1">#===================================================================</span>
    <span class="c1"># secondary constructors</span>
    <span class="c1">#===================================================================</span>
    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">_norm_source</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">source</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;internal helper - accepts string, dict, or context&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">source</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="o">**</span><span class="n">source</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">source</span><span class="p">,</span> <span class="bp">cls</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">source</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span> <span class="o">=</span> <span class="bp">cls</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">source</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_string</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">source</span><span class="p">,</span> <span class="n">section</span><span class="o">=</span><span class="s2">&quot;passlib&quot;</span><span class="p">,</span> <span class="n">encoding</span><span class="o">=</span><span class="s2">&quot;utf-8&quot;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;create new CryptContext instance from an INI-formatted string.</span>

<span class="sd">        :type source: unicode or bytes</span>
<span class="sd">        :arg source:</span>
<span class="sd">            string containing INI-formatted content.</span>

<span class="sd">        :type section: str</span>
<span class="sd">        :param section:</span>
<span class="sd">            option name of section to read from, defaults to ``&quot;passlib&quot;``.</span>

<span class="sd">        :type encoding: str</span>
<span class="sd">        :arg encoding:</span>
<span class="sd">            optional encoding used when source is bytes, defaults to ``&quot;utf-8&quot;``.</span>

<span class="sd">        :returns:</span>
<span class="sd">            new :class:`CryptContext` instance, configured based on the</span>
<span class="sd">            parameters in the *source* string.</span>

<span class="sd">        Usage example::</span>

<span class="sd">            &gt;&gt;&gt; from passlib.context import CryptContext</span>
<span class="sd">            &gt;&gt;&gt; context = CryptContext.from_string(&#39;&#39;&#39;</span>
<span class="sd">            ... [passlib]</span>
<span class="sd">            ... schemes = sha256_crypt, des_crypt</span>
<span class="sd">            ... sha256_crypt__default_rounds = 30000</span>
<span class="sd">            ... &#39;&#39;&#39;)</span>

<span class="sd">        .. versionadded:: 1.6</span>

<span class="sd">        .. seealso:: :meth:`to_string`, the inverse of this constructor.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">source</span><span class="p">,</span> <span class="n">unicode_or_bytes_types</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">ExpectedTypeError</span><span class="p">(</span><span class="n">source</span><span class="p">,</span> <span class="s2">&quot;unicode or bytes&quot;</span><span class="p">,</span> <span class="s2">&quot;source&quot;</span><span class="p">)</span>
        <span class="bp">self</span> <span class="o">=</span> <span class="bp">cls</span><span class="p">(</span><span class="n">_autoload</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">source</span><span class="p">,</span> <span class="n">section</span><span class="o">=</span><span class="n">section</span><span class="p">,</span> <span class="n">encoding</span><span class="o">=</span><span class="n">encoding</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_path</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="n">section</span><span class="o">=</span><span class="s2">&quot;passlib&quot;</span><span class="p">,</span> <span class="n">encoding</span><span class="o">=</span><span class="s2">&quot;utf-8&quot;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;create new CryptContext instance from an INI-formatted file.</span>

<span class="sd">        this functions exactly the same as :meth:`from_string`,</span>
<span class="sd">        except that it loads from a local file.</span>

<span class="sd">        :type path: str</span>
<span class="sd">        :arg path:</span>
<span class="sd">            path to local file containing INI-formatted config.</span>

<span class="sd">        :type section: str</span>
<span class="sd">        :param section:</span>
<span class="sd">            option name of section to read from, defaults to ``&quot;passlib&quot;``.</span>

<span class="sd">        :type encoding: str</span>
<span class="sd">        :arg encoding:</span>
<span class="sd">            encoding used to load file, defaults to ``&quot;utf-8&quot;``.</span>

<span class="sd">        :returns:</span>
<span class="sd">            new CryptContext instance, configured based on the parameters</span>
<span class="sd">            stored in the file *path*.</span>

<span class="sd">        .. versionadded:: 1.6</span>

<span class="sd">        .. seealso:: :meth:`from_string` for an equivalent usage example.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span> <span class="o">=</span> <span class="bp">cls</span><span class="p">(</span><span class="n">_autoload</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">load_path</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">section</span><span class="o">=</span><span class="n">section</span><span class="p">,</span> <span class="n">encoding</span><span class="o">=</span><span class="n">encoding</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">copy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return copy of existing CryptContext instance.</span>

<span class="sd">        This function returns a new CryptContext instance whose configuration</span>
<span class="sd">        is exactly the same as the original, with the exception that any keywords</span>
<span class="sd">        passed in will take precedence over the original settings.</span>
<span class="sd">        As an example::</span>

<span class="sd">            &gt;&gt;&gt; from passlib.context import CryptContext</span>

<span class="sd">            &gt;&gt;&gt; # given an existing context...</span>
<span class="sd">            &gt;&gt;&gt; ctx1 = CryptContext([&quot;sha256_crypt&quot;, &quot;md5_crypt&quot;])</span>

<span class="sd">            &gt;&gt;&gt; # copy can be used to make a clone, and update</span>
<span class="sd">            &gt;&gt;&gt; # some of the settings at the same time...</span>
<span class="sd">            &gt;&gt;&gt; ctx2 = custom_app_context.copy(default=&quot;md5_crypt&quot;)</span>

<span class="sd">            &gt;&gt;&gt; # and the original will be unaffected by the change</span>
<span class="sd">            &gt;&gt;&gt; ctx1.default_scheme()</span>
<span class="sd">            &quot;sha256_crypt&quot;</span>
<span class="sd">            &gt;&gt;&gt; ctx2.default_scheme()</span>
<span class="sd">            &quot;md5_crypt&quot;</span>

<span class="sd">        .. versionadded:: 1.6</span>
<span class="sd">            This method was previously named :meth:`!replace`. That alias</span>
<span class="sd">            has been deprecated, and will be removed in Passlib 1.8.</span>

<span class="sd">        .. seealso:: :meth:`update`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># XXX: it would be faster to store ref to self._config,</span>
        <span class="c1">#      but don&#39;t want to share config objects til sure</span>
        <span class="c1">#      can rely on them being immutable.</span>
        <span class="n">other</span> <span class="o">=</span> <span class="n">CryptContext</span><span class="p">(</span><span class="n">_autoload</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">other</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">kwds</span><span class="p">:</span>
            <span class="n">other</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">kwds</span><span class="p">,</span> <span class="n">update</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">other</span>

    <span class="k">def</span> <span class="nf">using</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        alias for :meth:`copy`, to match PasswordHash.using()</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="o">**</span><span class="n">kwds</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">replace</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;deprecated alias of :meth:`copy`&quot;&quot;&quot;</span>
        <span class="n">warn</span><span class="p">(</span><span class="s2">&quot;CryptContext().replace() has been deprecated in Passlib 1.6, &quot;</span>
             <span class="s2">&quot;and will be removed in Passlib 1.8, &quot;</span>
             <span class="s2">&quot;it has been renamed to CryptContext().copy()&quot;</span><span class="p">,</span>
             <span class="ne">DeprecationWarning</span><span class="p">,</span> <span class="n">stacklevel</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="o">**</span><span class="n">kwds</span><span class="p">)</span>

    <span class="c1">#===================================================================</span>
    <span class="c1"># init</span>
    <span class="c1">#===================================================================</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">schemes</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="c1"># keyword only...</span>
                 <span class="n">policy</span><span class="o">=</span><span class="n">_UNSET</span><span class="p">,</span> <span class="c1"># &lt;-- deprecated</span>
                 <span class="n">_autoload</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">):</span>
        <span class="c1"># XXX: add ability to make flag certain contexts as immutable,</span>
        <span class="c1">#      e.g. the builtin passlib ones?</span>
        <span class="c1"># XXX: add a name or import path for the contexts, to help out repr?</span>
        <span class="k">if</span> <span class="n">schemes</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">kwds</span><span class="p">[</span><span class="s1">&#39;schemes&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">schemes</span>
        <span class="k">if</span> <span class="n">policy</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">_UNSET</span><span class="p">:</span>
            <span class="n">warn</span><span class="p">(</span><span class="s2">&quot;The CryptContext ``policy`` keyword has been deprecated as of Passlib 1.6, &quot;</span>
                 <span class="s2">&quot;and will be removed in Passlib 1.8; please use &quot;</span>
                 <span class="s2">&quot;``CryptContext.from_string()` or &quot;</span>
                 <span class="s2">&quot;``CryptContext.from_path()`` instead.&quot;</span><span class="p">,</span>
                 <span class="ne">DeprecationWarning</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">policy</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">kwds</span><span class="p">)</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">policy</span><span class="p">,</span> <span class="n">CryptPolicy</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">policy</span><span class="o">.</span><span class="n">_context</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">kwds</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;policy must be a CryptPolicy instance&quot;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">_autoload</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">kwds</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">assert</span> <span class="ow">not</span> <span class="n">kwds</span><span class="p">,</span> <span class="s2">&quot;_autoload=False and kwds are mutually exclusive&quot;</span>

    <span class="c1"># XXX: would this be useful?</span>
    <span class="c1">##def __str__(self):</span>
    <span class="c1">##    if PY3:</span>
    <span class="c1">##        return self.to_string()</span>
    <span class="c1">##    else:</span>
    <span class="c1">##        return self.to_string().encode(&quot;utf-8&quot;)</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s2">&quot;&lt;CryptContext at 0x</span><span class="si">%0x</span><span class="s2">&gt;&quot;</span> <span class="o">%</span> <span class="nb">id</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="c1">#===================================================================</span>
    <span class="c1"># deprecated policy object</span>
    <span class="c1">#===================================================================</span>
    <span class="k">def</span> <span class="nf">_get_policy</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># The CryptPolicy class has been deprecated, so to support any</span>
        <span class="c1"># legacy accesses, we create a stub policy object so .policy attr</span>
        <span class="c1"># will continue to work.</span>
        <span class="c1">#</span>
        <span class="c1"># the code waits until app accesses a specific policy object attribute</span>
        <span class="c1"># before issuing deprecation warning, so developer gets method-specific</span>
        <span class="c1"># suggestion for how to upgrade.</span>

        <span class="c1"># NOTE: making a copy of the context so the policy acts like a snapshot,</span>
        <span class="c1"># to retain the pre-1.6 behavior.</span>
        <span class="k">return</span> <span class="n">CryptPolicy</span><span class="p">(</span><span class="n">_internal_context</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span> <span class="n">_stub_policy</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_set_policy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">policy</span><span class="p">):</span>
        <span class="n">warn</span><span class="p">(</span><span class="s2">&quot;The CryptPolicy class and the ``context.policy`` attribute have &quot;</span>
             <span class="s2">&quot;been deprecated as of Passlib 1.6, and will be removed in &quot;</span>
             <span class="s2">&quot;Passlib 1.8; please use the ``context.load()`` and &quot;</span>
             <span class="s2">&quot;``context.update()`` methods instead.&quot;</span><span class="p">,</span>
             <span class="ne">DeprecationWarning</span><span class="p">,</span> <span class="n">stacklevel</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">policy</span><span class="p">,</span> <span class="n">CryptPolicy</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">policy</span><span class="o">.</span><span class="n">_context</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;expected CryptPolicy instance&quot;</span><span class="p">)</span>

    <span class="n">policy</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="n">_get_policy</span><span class="p">,</span> <span class="n">_set_policy</span><span class="p">,</span>
                    <span class="n">doc</span><span class="o">=</span><span class="s2">&quot;[deprecated] returns CryptPolicy instance &quot;</span>
                        <span class="s2">&quot;tied to this CryptContext&quot;</span><span class="p">)</span>

    <span class="c1">#===================================================================</span>
    <span class="c1"># loading / updating configuration</span>
    <span class="c1">#===================================================================</span>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_parse_ini_stream</span><span class="p">(</span><span class="n">stream</span><span class="p">,</span> <span class="n">section</span><span class="p">,</span> <span class="n">filename</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;helper read INI from stream, extract passlib section as dict&quot;&quot;&quot;</span>
        <span class="c1"># NOTE: this expects a unicode stream under py3,</span>
        <span class="c1"># and a utf-8 bytes stream under py2,</span>
        <span class="c1"># allowing the resulting dict to always use native strings.</span>
        <span class="n">p</span> <span class="o">=</span> <span class="n">SafeConfigParser</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">PY3</span><span class="p">:</span>
            <span class="c1"># python 3.2 deprecated readfp in favor of read_file</span>
            <span class="n">p</span><span class="o">.</span><span class="n">read_file</span><span class="p">(</span><span class="n">stream</span><span class="p">,</span> <span class="n">filename</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">p</span><span class="o">.</span><span class="n">readfp</span><span class="p">(</span><span class="n">stream</span><span class="p">,</span> <span class="n">filename</span><span class="p">)</span>
        <span class="c1"># XXX: could change load() to accept list of items,</span>
        <span class="c1">#      and skip intermediate dict creation</span>
        <span class="k">return</span> <span class="nb">dict</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">items</span><span class="p">(</span><span class="n">section</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">load_path</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="n">update</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">section</span><span class="o">=</span><span class="s2">&quot;passlib&quot;</span><span class="p">,</span> <span class="n">encoding</span><span class="o">=</span><span class="s2">&quot;utf-8&quot;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Load new configuration into CryptContext from a local file.</span>

<span class="sd">        This function is a wrapper for :meth:`load` which</span>
<span class="sd">        loads a configuration string from the local file *path*,</span>
<span class="sd">        instead of an in-memory source. Its behavior and options</span>
<span class="sd">        are otherwise identical to :meth:`!load` when provided with</span>
<span class="sd">        an INI-formatted string.</span>

<span class="sd">        .. versionadded:: 1.6</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">def</span> <span class="nf">helper</span><span class="p">(</span><span class="n">stream</span><span class="p">):</span>
            <span class="n">kwds</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parse_ini_stream</span><span class="p">(</span><span class="n">stream</span><span class="p">,</span> <span class="n">section</span><span class="p">,</span> <span class="n">path</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">kwds</span><span class="p">,</span> <span class="n">update</span><span class="o">=</span><span class="n">update</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">PY3</span><span class="p">:</span>
            <span class="c1"># decode to unicode, which load() expected under py3</span>
            <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="s2">&quot;rt&quot;</span><span class="p">,</span> <span class="n">encoding</span><span class="o">=</span><span class="n">encoding</span><span class="p">)</span> <span class="k">as</span> <span class="n">stream</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">helper</span><span class="p">(</span><span class="n">stream</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">encoding</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;utf-8&quot;</span><span class="p">,</span> <span class="s2">&quot;ascii&quot;</span><span class="p">]:</span>
            <span class="c1"># keep as utf-8 bytes, which load() expects under py2</span>
            <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="s2">&quot;rb&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">stream</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">helper</span><span class="p">(</span><span class="n">stream</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># transcode to utf-8 bytes</span>
            <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="s2">&quot;rb&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">fh</span><span class="p">:</span>
                <span class="n">tmp</span> <span class="o">=</span> <span class="n">fh</span><span class="o">.</span><span class="n">read</span><span class="p">()</span><span class="o">.</span><span class="n">decode</span><span class="p">(</span><span class="n">encoding</span><span class="p">)</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="s2">&quot;utf-8&quot;</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">helper</span><span class="p">(</span><span class="n">BytesIO</span><span class="p">(</span><span class="n">tmp</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">load</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">source</span><span class="p">,</span> <span class="n">update</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">section</span><span class="o">=</span><span class="s2">&quot;passlib&quot;</span><span class="p">,</span> <span class="n">encoding</span><span class="o">=</span><span class="s2">&quot;utf-8&quot;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Load new configuration into CryptContext, replacing existing config.</span>

<span class="sd">        :arg source:</span>
<span class="sd">            source of new configuration to load.</span>
<span class="sd">            this value can be a number of different types:</span>

<span class="sd">            * a :class:`!dict` object, or compatible Mapping</span>

<span class="sd">                the key/value pairs will be interpreted the same</span>
<span class="sd">                keywords for the :class:`CryptContext` class constructor.</span>

<span class="sd">            * a :class:`!unicode` or :class:`!bytes` string</span>

<span class="sd">                this will be interpreted as an INI-formatted file,</span>
<span class="sd">                and appropriate key/value pairs will be loaded from</span>
<span class="sd">                the specified *section*.</span>

<span class="sd">            * another :class:`!CryptContext` object.</span>

<span class="sd">                this will export a snapshot of its configuration</span>
<span class="sd">                using :meth:`to_dict`.</span>

<span class="sd">        :type update: bool</span>
<span class="sd">        :param update:</span>
<span class="sd">            By default, :meth:`load` will replace the existing configuration</span>
<span class="sd">            entirely. If ``update=True``, it will preserve any existing</span>
<span class="sd">            configuration options that are not overridden by the new source,</span>
<span class="sd">            much like the :meth:`update` method.</span>

<span class="sd">        :type section: str</span>
<span class="sd">        :param section:</span>
<span class="sd">            When parsing an INI-formatted string, :meth:`load` will look for</span>
<span class="sd">            a section named ``&quot;passlib&quot;``. This option allows an alternate</span>
<span class="sd">            section name to be used. Ignored when loading from a dictionary.</span>

<span class="sd">        :type encoding: str</span>
<span class="sd">        :param encoding:</span>
<span class="sd">            Encoding to use when **source** is bytes.</span>
<span class="sd">            Defaults to ``&quot;utf-8&quot;``. Ignored when loading from a dictionary.</span>

<span class="sd">            .. deprecated:: 1.8</span>

<span class="sd">                This keyword, and support for bytes input, will be dropped in Passlib 2.0</span>

<span class="sd">        :raises TypeError:</span>
<span class="sd">            * If the source cannot be identified.</span>
<span class="sd">            * If an unknown / malformed keyword is encountered.</span>

<span class="sd">        :raises ValueError:</span>
<span class="sd">            If an invalid keyword value is encountered.</span>

<span class="sd">        .. note::</span>

<span class="sd">            If an error occurs during a :meth:`!load` call, the :class:`!CryptContext`</span>
<span class="sd">            instance will be restored to the configuration it was in before</span>
<span class="sd">            the :meth:`!load` call was made; this is to ensure it is</span>
<span class="sd">            *never* left in an inconsistent state due to a load error.</span>

<span class="sd">        .. versionadded:: 1.6</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1">#-----------------------------------------------------------</span>
        <span class="c1"># autodetect source type, convert to dict</span>
        <span class="c1">#-----------------------------------------------------------</span>
        <span class="n">parse_keys</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">source</span><span class="p">,</span> <span class="n">unicode_or_bytes_types</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">PY3</span><span class="p">:</span>
                <span class="n">source</span> <span class="o">=</span> <span class="n">to_unicode</span><span class="p">(</span><span class="n">source</span><span class="p">,</span> <span class="n">encoding</span><span class="p">,</span> <span class="n">param</span><span class="o">=</span><span class="s2">&quot;source&quot;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">source</span> <span class="o">=</span> <span class="n">to_bytes</span><span class="p">(</span><span class="n">source</span><span class="p">,</span> <span class="s2">&quot;utf-8&quot;</span><span class="p">,</span> <span class="n">source_encoding</span><span class="o">=</span><span class="n">encoding</span><span class="p">,</span>
                                  <span class="n">param</span><span class="o">=</span><span class="s2">&quot;source&quot;</span><span class="p">)</span>
            <span class="n">source</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parse_ini_stream</span><span class="p">(</span><span class="n">NativeStringIO</span><span class="p">(</span><span class="n">source</span><span class="p">),</span> <span class="n">section</span><span class="p">,</span>
                                            <span class="s2">&quot;&lt;string passed to CryptContext.load()&gt;&quot;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">source</span><span class="p">,</span> <span class="n">CryptContext</span><span class="p">):</span>
            <span class="c1"># extract dict directly from config, so it can be merged later</span>
            <span class="n">source</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">source</span><span class="o">.</span><span class="n">_config</span><span class="o">.</span><span class="n">iter_config</span><span class="p">(</span><span class="n">resolve</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>
            <span class="n">parse_keys</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">source</span><span class="p">,</span> <span class="s2">&quot;items&quot;</span><span class="p">):</span>
            <span class="c1"># mappings are left alone, otherwise throw an error.</span>
            <span class="k">raise</span> <span class="n">ExpectedTypeError</span><span class="p">(</span><span class="n">source</span><span class="p">,</span> <span class="s2">&quot;string or dict&quot;</span><span class="p">,</span> <span class="s2">&quot;source&quot;</span><span class="p">)</span>

        <span class="c1"># XXX: add support for other iterable types, e.g. sequence of pairs?</span>

        <span class="c1">#-----------------------------------------------------------</span>
        <span class="c1"># parse dict keys into (category, scheme, option) format,</span>
        <span class="c1"># and merge with existing configuration if needed.</span>
        <span class="c1">#-----------------------------------------------------------</span>
        <span class="k">if</span> <span class="n">parse_keys</span><span class="p">:</span>
            <span class="n">parse</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parse_config_key</span>
            <span class="n">source</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">((</span><span class="n">parse</span><span class="p">(</span><span class="n">key</span><span class="p">),</span> <span class="n">value</span><span class="p">)</span>
                          <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">iteritems</span><span class="p">(</span><span class="n">source</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">update</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_config</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># if updating, do nothing if source is empty,</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">source</span><span class="p">:</span>
                <span class="k">return</span>
            <span class="c1"># otherwise overlay source on top of existing config</span>
            <span class="n">tmp</span> <span class="o">=</span> <span class="n">source</span>
            <span class="n">source</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_config</span><span class="o">.</span><span class="n">iter_config</span><span class="p">(</span><span class="n">resolve</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>
            <span class="n">source</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">tmp</span><span class="p">)</span>

        <span class="c1">#-----------------------------------------------------------</span>
        <span class="c1"># compile into _CryptConfig instance, and update state</span>
        <span class="c1">#-----------------------------------------------------------</span>
        <span class="n">config</span> <span class="o">=</span> <span class="n">_CryptConfig</span><span class="p">(</span><span class="n">source</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_config</span> <span class="o">=</span> <span class="n">config</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_reset_dummy_verify</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_get_record</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">get_record</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_identify_record</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">identify_record</span>
        <span class="k">if</span> <span class="n">config</span><span class="o">.</span><span class="n">context_kwds</span><span class="p">:</span>
            <span class="c1"># (re-)enable method for this instance (in case ELSE clause below ran last load).</span>
            <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;_strip_unused_context_kwds&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># disable method for this instance, it&#39;s not needed.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_strip_unused_context_kwds</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_parse_config_key</span><span class="p">(</span><span class="n">ckey</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;helper used to parse ``cat__scheme__option`` keys into a tuple&quot;&quot;&quot;</span>
        <span class="c1"># split string into 1-3 parts</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ckey</span><span class="p">,</span> <span class="n">native_string_types</span><span class="p">)</span>
        <span class="n">parts</span> <span class="o">=</span> <span class="n">ckey</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;.&quot;</span><span class="p">,</span> <span class="s2">&quot;__&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;__&quot;</span><span class="p">)</span>
        <span class="n">count</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">parts</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">count</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">cat</span><span class="p">,</span> <span class="n">scheme</span><span class="p">,</span> <span class="n">key</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="n">parts</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">count</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">cat</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="n">scheme</span><span class="p">,</span> <span class="n">key</span> <span class="o">=</span> <span class="n">parts</span>
        <span class="k">elif</span> <span class="n">count</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
            <span class="n">cat</span><span class="p">,</span> <span class="n">scheme</span><span class="p">,</span> <span class="n">key</span> <span class="o">=</span> <span class="n">parts</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;keys must have less than 3 separators: </span><span class="si">%r</span><span class="s2">&quot;</span> <span class="o">%</span>
                            <span class="p">(</span><span class="n">ckey</span><span class="p">,))</span>
        <span class="c1"># validate &amp; normalize the parts</span>
        <span class="k">if</span> <span class="n">cat</span> <span class="o">==</span> <span class="s2">&quot;default&quot;</span><span class="p">:</span>
            <span class="n">cat</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="n">cat</span> <span class="ow">and</span> <span class="n">cat</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;empty category: </span><span class="si">%r</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">ckey</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">scheme</span> <span class="o">==</span> <span class="s2">&quot;context&quot;</span><span class="p">:</span>
            <span class="n">scheme</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="n">scheme</span> <span class="ow">and</span> <span class="n">scheme</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;empty scheme: </span><span class="si">%r</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">ckey</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">key</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;empty option: </span><span class="si">%r</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">ckey</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">cat</span><span class="p">,</span> <span class="n">scheme</span><span class="p">,</span> <span class="n">key</span>

    <span class="k">def</span> <span class="nf">update</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Helper for quickly changing configuration.</span>

<span class="sd">        This acts much like the :meth:`!dict.update` method:</span>
<span class="sd">        it updates the context&#39;s configuration,</span>
<span class="sd">        replacing the original value(s) for the specified keys,</span>
<span class="sd">        and preserving the rest.</span>
<span class="sd">        It accepts any :ref:`keyword &lt;context-options&gt;`</span>
<span class="sd">        accepted by the :class:`!CryptContext` constructor.</span>

<span class="sd">        .. versionadded:: 1.6</span>

<span class="sd">        .. seealso:: :meth:`copy`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">args</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;expected at most one positional argument&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">kwds</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;positional arg and keywords mutually exclusive&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">update</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">kwds</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">kwds</span><span class="p">,</span> <span class="n">update</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="c1"># XXX: make this public? even just as flag to load?</span>
    <span class="c1"># FIXME: this function suffered some bitrot in 1.6.1,</span>
    <span class="c1">#        will need to be updated before works again.</span>
    <span class="c1">##def _simplify(self):</span>
    <span class="c1">##    &quot;helper to remove redundant/unused options&quot;</span>
    <span class="c1">##    # don&#39;t do anything if no schemes are defined</span>
    <span class="c1">##    if not self._schemes:</span>
    <span class="c1">##        return</span>
    <span class="c1">##</span>
    <span class="c1">##    def strip_items(target, filter):</span>
    <span class="c1">##        keys = [key for key,value in iteritems(target)</span>
    <span class="c1">##                if filter(key,value)]</span>
    <span class="c1">##        for key in keys:</span>
    <span class="c1">##            del target[key]</span>
    <span class="c1">##</span>
    <span class="c1">##    # remove redundant default.</span>
    <span class="c1">##    defaults = self._default_schemes</span>
    <span class="c1">##    if defaults.get(None) == self._schemes[0]:</span>
    <span class="c1">##        del defaults[None]</span>
    <span class="c1">##</span>
    <span class="c1">##    # remove options for unused schemes.</span>
    <span class="c1">##    scheme_options = self._scheme_options</span>
    <span class="c1">##    schemes = self._schemes + (&quot;all&quot;,)</span>
    <span class="c1">##    strip_items(scheme_options, lambda k,v: k not in schemes)</span>
    <span class="c1">##</span>
    <span class="c1">##    # remove rendundant cat defaults.</span>
    <span class="c1">##    cur = self.default_scheme()</span>
    <span class="c1">##    strip_items(defaults, lambda k,v: k and v==cur)</span>
    <span class="c1">##</span>
    <span class="c1">##    # remove redundant category deprecations.</span>
    <span class="c1">##    # TODO: this should work w/ &#39;auto&#39;, but needs closer inspection</span>
    <span class="c1">##    deprecated = self._deprecated_schemes</span>
    <span class="c1">##    cur = self._deprecated_schemes.get(None)</span>
    <span class="c1">##    strip_items(deprecated, lambda k,v: k and v==cur)</span>
    <span class="c1">##</span>
    <span class="c1">##    # remove redundant category options.</span>
    <span class="c1">##    for scheme, config in iteritems(scheme_options):</span>
    <span class="c1">##        if None in config:</span>
    <span class="c1">##            cur = config[None]</span>
    <span class="c1">##            strip_items(config, lambda k,v: k and v==cur)</span>
    <span class="c1">##</span>
    <span class="c1">##    # XXX: anything else?</span>

    <span class="c1">#===================================================================</span>
    <span class="c1"># reading configuration</span>
    <span class="c1">#===================================================================</span>
    <span class="k">def</span> <span class="nf">schemes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">resolve</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">category</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">unconfigured</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;return schemes loaded into this CryptContext instance.</span>

<span class="sd">        :type resolve: bool</span>
<span class="sd">        :arg resolve:</span>
<span class="sd">            if ``True``, will return a tuple of :class:`~passlib.ifc.PasswordHash`</span>
<span class="sd">            objects instead of their names.</span>

<span class="sd">        :returns:</span>
<span class="sd">            returns tuple of the schemes configured for this context</span>
<span class="sd">            via the *schemes* option.</span>

<span class="sd">        .. versionadded:: 1.6</span>
<span class="sd">            This was previously available as ``CryptContext().policy.schemes()``</span>

<span class="sd">        .. seealso:: the :ref:`schemes &lt;context-schemes-option&gt;` option for usage example.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># XXX: should resolv return records rather than handlers?</span>
        <span class="c1">#      or deprecate resolve keyword completely?</span>
        <span class="c1">#      offering up a .hashers Mapping in v1.8 would be great.</span>
        <span class="c1"># NOTE: supporting &#39;category&#39; and &#39;unconfigured&#39; kwds as of 1.7</span>
        <span class="c1">#       just to pass through to .handler(), but not documenting them...</span>
        <span class="c1">#       may not need to put them to use.</span>
        <span class="n">schemes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_config</span><span class="o">.</span><span class="n">schemes</span>
        <span class="k">if</span> <span class="n">resolve</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">handler</span><span class="p">(</span><span class="n">scheme</span><span class="p">,</span> <span class="n">category</span><span class="p">,</span> <span class="n">unconfigured</span><span class="o">=</span><span class="n">unconfigured</span><span class="p">)</span>
                         <span class="k">for</span> <span class="n">scheme</span> <span class="ow">in</span> <span class="n">schemes</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">schemes</span>

    <span class="k">def</span> <span class="nf">default_scheme</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">category</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">resolve</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">unconfigured</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;return name of scheme that :meth:`hash` will use by default.</span>

<span class="sd">        :type resolve: bool</span>
<span class="sd">        :arg resolve:</span>
<span class="sd">            if ``True``, will return a :class:`~passlib.ifc.PasswordHash`</span>
<span class="sd">            object instead of the name.</span>

<span class="sd">        :type category: str or None</span>
<span class="sd">        :param category:</span>
<span class="sd">            Optional :ref:`user category &lt;user-categories&gt;`.</span>
<span class="sd">            If specified, this will return the catgory-specific default scheme instead.</span>

<span class="sd">        :returns:</span>
<span class="sd">            name of the default scheme.</span>

<span class="sd">        .. seealso:: the :ref:`default &lt;context-default-option&gt;` option for usage example.</span>

<span class="sd">        .. versionadded:: 1.6</span>

<span class="sd">        .. versionchanged:: 1.7</span>

<span class="sd">            This now returns a hasher configured with any CryptContext-specific</span>
<span class="sd">            options (custom rounds settings, etc).  Previously this returned</span>
<span class="sd">            the base hasher from :mod:`passlib.hash`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># XXX: deprecate this in favor of .handler() or whatever it&#39;s replaced with?</span>
        <span class="c1"># NOTE: supporting &#39;unconfigured&#39; kwds as of 1.7</span>
        <span class="c1">#       just to pass through to .handler(), but not documenting them...</span>
        <span class="c1">#       may not need to put them to use.</span>
        <span class="n">hasher</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">handler</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="n">category</span><span class="p">,</span> <span class="n">unconfigured</span><span class="o">=</span><span class="n">unconfigured</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">hasher</span> <span class="k">if</span> <span class="n">resolve</span> <span class="k">else</span> <span class="n">hasher</span><span class="o">.</span><span class="n">name</span>

    <span class="c1"># XXX: need to decide if exposing this would be useful in any way</span>
    <span class="c1">##def categories(self):</span>
    <span class="c1">##    &quot;&quot;&quot;return user-categories with algorithm-specific options in this CryptContext.</span>
    <span class="c1">##</span>
    <span class="c1">##    this will always return a tuple.</span>
    <span class="c1">##    if no categories besides the default category have been configured,</span>
    <span class="c1">##    the tuple will be empty.</span>
    <span class="c1">##    &quot;&quot;&quot;</span>
    <span class="c1">##    return self._config.categories</span>

    <span class="c1"># XXX: need to decide if exposing this would be useful to applications</span>
    <span class="c1"># in any meaningful way that isn&#39;t already served by to_dict()</span>
    <span class="c1">##def options(self, scheme, category=None):</span>
    <span class="c1">##    kwds, percat = self._config.get_options(scheme, category)</span>
    <span class="c1">##    return kwds</span>

    <span class="k">def</span> <span class="nf">handler</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">scheme</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">category</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">unconfigured</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;helper to resolve name of scheme -&gt; :class:`~passlib.ifc.PasswordHash` object used by scheme.</span>

<span class="sd">        :arg scheme:</span>
<span class="sd">            This should identify the scheme to lookup.</span>
<span class="sd">            If omitted or set to ``None``, this will return the handler</span>
<span class="sd">            for the default scheme.</span>

<span class="sd">        :arg category:</span>
<span class="sd">            If a user category is specified, and no scheme is provided,</span>
<span class="sd">            it will use the default for that category.</span>
<span class="sd">            Otherwise this parameter is ignored.</span>

<span class="sd">        :param unconfigured:</span>

<span class="sd">            By default, this returns a handler object whose .hash()</span>
<span class="sd">            and .needs_update() methods will honor the configured</span>
<span class="sd">            provided by CryptContext.   See ``unconfigured=True``</span>
<span class="sd">            to get the underlying handler from before any context-specific</span>
<span class="sd">            configuration was applied.</span>

<span class="sd">        :raises KeyError:</span>
<span class="sd">            If the scheme does not exist OR is not being used within this context.</span>

<span class="sd">        :returns:</span>
<span class="sd">            :class:`~passlib.ifc.PasswordHash` object used to implement</span>
<span class="sd">            the named scheme within this context (this will usually</span>
<span class="sd">            be one of the objects from :mod:`passlib.hash`)</span>

<span class="sd">        .. versionadded:: 1.6</span>
<span class="sd">            This was previously available as ``CryptContext().policy.get_handler()``</span>

<span class="sd">        .. versionchanged:: 1.7</span>

<span class="sd">            This now returns a hasher configured with any CryptContext-specific</span>
<span class="sd">            options (custom rounds settings, etc).  Previously this returned</span>
<span class="sd">            the base hasher from :mod:`passlib.hash`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">hasher</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_record</span><span class="p">(</span><span class="n">scheme</span><span class="p">,</span> <span class="n">category</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">unconfigured</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">hasher</span><span class="o">.</span><span class="n">_Context__orig_handler</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">hasher</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="k">pass</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_config</span><span class="o">.</span><span class="n">handlers</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="s2">&quot;crypt algorithm not found in this &quot;</span>
                           <span class="s2">&quot;CryptContext instance: </span><span class="si">%r</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">scheme</span><span class="p">,))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="s2">&quot;no crypt algorithms loaded in this &quot;</span>
                           <span class="s2">&quot;CryptContext instance&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_get_unregistered_handlers</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;check if any handlers in this context aren&#39;t in the global registry&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">handler</span> <span class="k">for</span> <span class="n">handler</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_config</span><span class="o">.</span><span class="n">handlers</span>
                     <span class="k">if</span> <span class="ow">not</span> <span class="n">_is_handler_registered</span><span class="p">(</span><span class="n">handler</span><span class="p">))</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">context_kwds</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        return :class:`!set` containing union of all :ref:`contextual keywords &lt;context-keywords&gt;`</span>
<span class="sd">        supported by the handlers in this context.</span>

<span class="sd">        .. versionadded:: 1.6.6</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_config</span><span class="o">.</span><span class="n">context_kwds</span>

    <span class="c1">#===================================================================</span>
    <span class="c1"># exporting config</span>
    <span class="c1">#===================================================================</span>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_render_config_key</span><span class="p">(</span><span class="n">key</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;convert 3-part config key to single string&quot;&quot;&quot;</span>
        <span class="n">cat</span><span class="p">,</span> <span class="n">scheme</span><span class="p">,</span> <span class="n">option</span> <span class="o">=</span> <span class="n">key</span>
        <span class="k">if</span> <span class="n">cat</span><span class="p">:</span>
            <span class="k">return</span> <span class="s2">&quot;</span><span class="si">%s</span><span class="s2">__</span><span class="si">%s</span><span class="s2">__</span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">cat</span><span class="p">,</span> <span class="n">scheme</span> <span class="ow">or</span> <span class="s2">&quot;context&quot;</span><span class="p">,</span> <span class="n">option</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">scheme</span><span class="p">:</span>
            <span class="k">return</span> <span class="s2">&quot;</span><span class="si">%s</span><span class="s2">__</span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">scheme</span><span class="p">,</span> <span class="n">option</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">option</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_render_ini_value</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;render value to string suitable for INI file&quot;&quot;&quot;</span>
        <span class="c1"># convert lists to comma separated lists</span>
        <span class="c1"># (mainly &#39;schemes&#39; &amp; &#39;deprecated&#39;)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span><span class="nb">tuple</span><span class="p">)):</span>
            <span class="n">value</span> <span class="o">=</span> <span class="s2">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>

        <span class="c1"># convert numbers to strings</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">num_types</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="nb">float</span><span class="p">)</span> <span class="ow">and</span> <span class="n">key</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;vary_rounds&quot;</span><span class="p">:</span>
                <span class="n">value</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;</span><span class="si">%.2f</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">value</span><span class="p">)</span><span class="o">.</span><span class="n">rstrip</span><span class="p">(</span><span class="s2">&quot;0&quot;</span><span class="p">)</span> <span class="k">if</span> <span class="n">value</span> <span class="k">else</span> <span class="s2">&quot;0&quot;</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">value</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>

        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">native_string_types</span><span class="p">),</span> \
               <span class="s2">&quot;expected string for key: </span><span class="si">%r</span><span class="s2"> </span><span class="si">%r</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>

        <span class="c1"># escape any percent signs.</span>
        <span class="k">return</span> <span class="n">value</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;%&quot;</span><span class="p">,</span> <span class="s2">&quot;</span><span class="si">%%</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">to_dict</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">resolve</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return current configuration as a dictionary.</span>

<span class="sd">        :type resolve: bool</span>
<span class="sd">        :arg resolve:</span>
<span class="sd">            if ``True``, the ``schemes`` key will contain a list of</span>
<span class="sd">            a :class:`~passlib.ifc.PasswordHash` objects instead of just</span>
<span class="sd">            their names.</span>

<span class="sd">        This method dumps the current configuration of the CryptContext</span>
<span class="sd">        instance. The key/value pairs should be in the format accepted</span>
<span class="sd">        by the :class:`!CryptContext` class constructor, in fact</span>
<span class="sd">        ``CryptContext(**myctx.to_dict())`` will create an exact copy of ``myctx``.</span>
<span class="sd">        As an example::</span>

<span class="sd">            &gt;&gt;&gt; # you can dump the configuration of any crypt context...</span>
<span class="sd">            &gt;&gt;&gt; from passlib.apps import ldap_nocrypt_context</span>
<span class="sd">            &gt;&gt;&gt; ldap_nocrypt_context.to_dict()</span>
<span class="sd">            {&#39;schemes&#39;: [&#39;ldap_salted_sha1&#39;,</span>
<span class="sd">            &#39;ldap_salted_md5&#39;,</span>
<span class="sd">            &#39;ldap_sha1&#39;,</span>
<span class="sd">            &#39;ldap_md5&#39;,</span>
<span class="sd">            &#39;ldap_plaintext&#39;]}</span>

<span class="sd">        .. versionadded:: 1.6</span>
<span class="sd">            This was previously available as ``CryptContext().policy.to_dict()``</span>

<span class="sd">        .. seealso:: the :ref:`context-serialization-example` example in the tutorial.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># XXX: should resolve default to conditional behavior</span>
        <span class="c1"># based on presence of unregistered handlers?</span>
        <span class="n">render_key</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_render_config_key</span>
        <span class="k">return</span> <span class="nb">dict</span><span class="p">((</span><span class="n">render_key</span><span class="p">(</span><span class="n">key</span><span class="p">),</span> <span class="n">value</span><span class="p">)</span>
                    <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_config</span><span class="o">.</span><span class="n">iter_config</span><span class="p">(</span><span class="n">resolve</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">_write_to_parser</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parser</span><span class="p">,</span> <span class="n">section</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;helper to write to ConfigParser instance&quot;&quot;&quot;</span>
        <span class="n">render_key</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_render_config_key</span>
        <span class="n">render_value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_render_ini_value</span>
        <span class="n">parser</span><span class="o">.</span><span class="n">add_section</span><span class="p">(</span><span class="n">section</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span><span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_config</span><span class="o">.</span><span class="n">iter_config</span><span class="p">():</span>
            <span class="n">v</span> <span class="o">=</span> <span class="n">render_value</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
            <span class="n">k</span> <span class="o">=</span> <span class="n">render_key</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
            <span class="n">parser</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">section</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">to_string</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">section</span><span class="o">=</span><span class="s2">&quot;passlib&quot;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;serialize to INI format and return as unicode string.</span>

<span class="sd">        :param section:</span>
<span class="sd">            name of INI section to output, defaults to ``&quot;passlib&quot;``.</span>

<span class="sd">        :returns:</span>
<span class="sd">            CryptContext configuration, serialized to a INI unicode string.</span>

<span class="sd">        This function acts exactly like :meth:`to_dict`, except that it</span>
<span class="sd">        serializes all the contents into a single human-readable string,</span>
<span class="sd">        which can be hand edited, and/or stored in a file. The</span>
<span class="sd">        output of this method is accepted by :meth:`from_string`,</span>
<span class="sd">        :meth:`from_path`, and :meth:`load`. As an example::</span>

<span class="sd">            &gt;&gt;&gt; # you can dump the configuration of any crypt context...</span>
<span class="sd">            &gt;&gt;&gt; from passlib.apps import ldap_nocrypt_context</span>
<span class="sd">            &gt;&gt;&gt; print ldap_nocrypt_context.to_string()</span>
<span class="sd">            [passlib]</span>
<span class="sd">            schemes = ldap_salted_sha1, ldap_salted_md5, ldap_sha1, ldap_md5, ldap_plaintext</span>

<span class="sd">        .. versionadded:: 1.6</span>
<span class="sd">            This was previously available as ``CryptContext().policy.to_string()``</span>

<span class="sd">        .. seealso:: the :ref:`context-serialization-example` example in the tutorial.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">parser</span> <span class="o">=</span> <span class="n">SafeConfigParser</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_write_to_parser</span><span class="p">(</span><span class="n">parser</span><span class="p">,</span> <span class="n">section</span><span class="p">)</span>
        <span class="n">buf</span> <span class="o">=</span> <span class="n">NativeStringIO</span><span class="p">()</span>
        <span class="n">parser</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">buf</span><span class="p">)</span>
        <span class="n">unregistered</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_unregistered_handlers</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">unregistered</span><span class="p">:</span>
            <span class="n">buf</span><span class="o">.</span><span class="n">write</span><span class="p">((</span>
                <span class="s2">&quot;# NOTE: the </span><span class="si">%s</span><span class="s2"> handler(s) are not registered with Passlib,</span><span class="se">\n</span><span class="s2">&quot;</span>
                <span class="s2">&quot;# this string may not correctly reproduce the current configuration.</span><span class="se">\n\n</span><span class="s2">&quot;</span>
                <span class="p">)</span> <span class="o">%</span> <span class="s2">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">repr</span><span class="p">(</span><span class="n">handler</span><span class="o">.</span><span class="n">name</span><span class="p">)</span> <span class="k">for</span> <span class="n">handler</span> <span class="ow">in</span> <span class="n">unregistered</span><span class="p">))</span>
        <span class="n">out</span> <span class="o">=</span> <span class="n">buf</span><span class="o">.</span><span class="n">getvalue</span><span class="p">()</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">PY3</span><span class="p">:</span>
            <span class="n">out</span> <span class="o">=</span> <span class="n">out</span><span class="o">.</span><span class="n">decode</span><span class="p">(</span><span class="s2">&quot;utf-8&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">out</span>

    <span class="c1"># XXX: is this useful enough to enable?</span>
    <span class="c1">##def write_to_path(self, path, section=&quot;passlib&quot;, update=False):</span>
    <span class="c1">##    &quot;write to INI file&quot;</span>
    <span class="c1">##    parser = ConfigParser()</span>
    <span class="c1">##    if update and os.path.exists(path):</span>
    <span class="c1">##        if not parser.read([path]):</span>
    <span class="c1">##            raise EnvironmentError(&quot;failed to read existing file&quot;)</span>
    <span class="c1">##        parser.remove_section(section)</span>
    <span class="c1">##    self._write_to_parser(parser, section)</span>
    <span class="c1">##    fh = file(path, &quot;w&quot;)</span>
    <span class="c1">##    parser.write(fh)</span>
    <span class="c1">##    fh.close()</span>

    <span class="c1">#===================================================================</span>
    <span class="c1"># verify() hardening</span>
    <span class="c1"># NOTE: this entire feature has been disabled.</span>
    <span class="c1">#       all contents of this section are NOOPs as of 1.7.1,</span>
    <span class="c1">#       and will be removed in 1.8.</span>
    <span class="c1">#===================================================================</span>

    <span class="n">mvt_estimate_max_samples</span> <span class="o">=</span> <span class="mi">20</span>
    <span class="n">mvt_estimate_min_samples</span> <span class="o">=</span> <span class="mi">10</span>
    <span class="n">mvt_estimate_max_time</span> <span class="o">=</span> <span class="mi">2</span>
    <span class="n">mvt_estimate_resolution</span> <span class="o">=</span> <span class="mf">0.01</span>
    <span class="n">harden_verify</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">min_verify_time</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">def</span> <span class="nf">reset_min_verify_time</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_reset_dummy_verify</span><span class="p">()</span>

    <span class="c1">#===================================================================</span>
    <span class="c1"># password hash api</span>
    <span class="c1">#===================================================================</span>

    <span class="c1"># NOTE: all the following methods do is look up the appropriate</span>
    <span class="c1">#       custom handler for a given (scheme,category) combination,</span>
    <span class="c1">#       and hand off the real work to the handler itself,</span>
    <span class="c1">#       which is optimized for the specific (scheme,category) configuration.</span>
    <span class="c1">#</span>
    <span class="c1">#       The custom handlers are cached inside the _CryptConfig</span>
    <span class="c1">#       instance stored in self._config, and are retrieved</span>
    <span class="c1">#       via get_record() and identify_record().</span>
    <span class="c1">#</span>
    <span class="c1">#       _get_record() and _identify_record() are references</span>
    <span class="c1">#       to _config methods of the same name,</span>
    <span class="c1">#       stored in CryptContext for speed.</span>

    <span class="k">def</span> <span class="nf">_get_or_identify_record</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">hash</span><span class="p">,</span> <span class="n">scheme</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">category</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;return record based on scheme, or failing that, by identifying hash&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">scheme</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="nb">hash</span><span class="p">,</span> <span class="n">unicode_or_bytes_types</span><span class="p">):</span>
                <span class="k">raise</span> <span class="n">ExpectedStringError</span><span class="p">(</span><span class="nb">hash</span><span class="p">,</span> <span class="s2">&quot;hash&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_record</span><span class="p">(</span><span class="n">scheme</span><span class="p">,</span> <span class="n">category</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># hash typecheck handled by identify_record()</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_identify_record</span><span class="p">(</span><span class="nb">hash</span><span class="p">,</span> <span class="n">category</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_strip_unused_context_kwds</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">kwds</span><span class="p">,</span> <span class="n">record</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        helper which removes any context keywords from **kwds**</span>
<span class="sd">        that are known to be used by another scheme in this context,</span>
<span class="sd">        but are NOT supported by handler specified by **record**.</span>

<span class="sd">        .. note::</span>
<span class="sd">            as optimization, load() will set this method to None on a per-instance basis</span>
<span class="sd">            if there are no context kwds.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">kwds</span><span class="p">:</span>
            <span class="k">return</span>
        <span class="n">unused_kwds</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_config</span><span class="o">.</span><span class="n">context_kwds</span><span class="o">.</span><span class="n">difference</span><span class="p">(</span><span class="n">record</span><span class="o">.</span><span class="n">context_kwds</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">unused_kwds</span><span class="p">:</span>
            <span class="n">kwds</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">needs_update</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">hash</span><span class="p">,</span> <span class="n">scheme</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">category</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">secret</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Check if hash needs to be replaced for some reason,</span>
<span class="sd">        in which case the secret should be re-hashed.</span>

<span class="sd">        This function is the core of CryptContext&#39;s support for hash migration:</span>
<span class="sd">        This function takes in a hash string, and checks the scheme,</span>
<span class="sd">        number of rounds, and other properties against the current policy.</span>
<span class="sd">        It returns ``True`` if the hash is using a deprecated scheme,</span>
<span class="sd">        or is otherwise outside of the bounds specified by the policy</span>
<span class="sd">        (e.g. the number of rounds is lower than :ref:`min_rounds &lt;context-min-rounds-option&gt;`</span>
<span class="sd">        configuration for that algorithm).</span>
<span class="sd">        If so, the password should be re-hashed using :meth:`hash`</span>
<span class="sd">        Otherwise, it will return ``False``.</span>

<span class="sd">        :type hash: unicode or bytes</span>
<span class="sd">        :arg hash:</span>
<span class="sd">            The hash string to examine.</span>

<span class="sd">        :type scheme: str or None</span>
<span class="sd">        :param scheme:</span>

<span class="sd">            Optional scheme to use. Scheme must be one of the ones</span>
<span class="sd">            configured for this context (see the</span>
<span class="sd">            :ref:`schemes &lt;context-schemes-option&gt;` option).</span>
<span class="sd">            If no scheme is specified, it will be identified</span>
<span class="sd">            based on the value of *hash*.</span>

<span class="sd">            .. deprecated:: 1.7</span>

<span class="sd">                Support for this keyword is deprecated, and will be removed in Passlib 2.0.</span>

<span class="sd">        :type category: str or None</span>
<span class="sd">        :param category:</span>
<span class="sd">            Optional :ref:`user category &lt;user-categories&gt;`.</span>
<span class="sd">            If specified, this will cause any category-specific defaults to</span>
<span class="sd">            be used when determining if the hash needs to be updated</span>
<span class="sd">            (e.g. is below the minimum rounds).</span>

<span class="sd">        :type secret: unicode, bytes, or None</span>
<span class="sd">        :param secret:</span>
<span class="sd">            Optional secret associated with the provided ``hash``.</span>
<span class="sd">            This is not required, or even currently used for anything...</span>
<span class="sd">            it&#39;s for forward-compatibility with any future</span>
<span class="sd">            update checks that might need this information.</span>
<span class="sd">            If provided, Passlib assumes the secret has already been</span>
<span class="sd">            verified successfully against the hash.</span>

<span class="sd">            .. versionadded:: 1.6</span>

<span class="sd">        :returns: ``True`` if hash should be replaced, otherwise ``False``.</span>

<span class="sd">        :raises ValueError:</span>
<span class="sd">            If the hash did not match any of the configured :meth:`schemes`.</span>

<span class="sd">        .. versionadded:: 1.6</span>
<span class="sd">            This method was previously named :meth:`hash_needs_update`.</span>

<span class="sd">        .. seealso:: the :ref:`context-migration-example` example in the tutorial.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">scheme</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># TODO: offer replacement alternative.</span>
            <span class="c1">#       ``context.handler(scheme).needs_update()`` would work,</span>
            <span class="c1">#       but may deprecate .handler() in passlib 1.8.</span>
            <span class="n">warn</span><span class="p">(</span><span class="s2">&quot;CryptContext.needs_update(): &#39;scheme&#39; keyword is deprecated as of &quot;</span>
                 <span class="s2">&quot;Passlib 1.7, and will be removed in Passlib 2.0&quot;</span><span class="p">,</span>
                 <span class="ne">DeprecationWarning</span><span class="p">)</span>
        <span class="n">record</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_or_identify_record</span><span class="p">(</span><span class="nb">hash</span><span class="p">,</span> <span class="n">scheme</span><span class="p">,</span> <span class="n">category</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">record</span><span class="o">.</span><span class="n">deprecated</span> <span class="ow">or</span> <span class="n">record</span><span class="o">.</span><span class="n">needs_update</span><span class="p">(</span><span class="nb">hash</span><span class="p">,</span> <span class="n">secret</span><span class="o">=</span><span class="n">secret</span><span class="p">)</span>

    <span class="nd">@deprecated_method</span><span class="p">(</span><span class="n">deprecated</span><span class="o">=</span><span class="s2">&quot;1.6&quot;</span><span class="p">,</span> <span class="n">removed</span><span class="o">=</span><span class="s2">&quot;2.0&quot;</span><span class="p">,</span> <span class="n">replacement</span><span class="o">=</span><span class="s2">&quot;CryptContext.needs_update()&quot;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">hash_needs_update</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">hash</span><span class="p">,</span> <span class="n">scheme</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">category</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Legacy alias for :meth:`needs_update`.</span>

<span class="sd">        .. deprecated:: 1.6</span>
<span class="sd">            This method was renamed to :meth:`!needs_update` in version 1.6.</span>
<span class="sd">            This alias will be removed in version 2.0, and should only</span>
<span class="sd">            be used for compatibility with Passlib 1.3 - 1.5.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">needs_update</span><span class="p">(</span><span class="nb">hash</span><span class="p">,</span> <span class="n">scheme</span><span class="p">,</span> <span class="n">category</span><span class="p">)</span>

    <span class="nd">@deprecated_method</span><span class="p">(</span><span class="n">deprecated</span><span class="o">=</span><span class="s2">&quot;1.7&quot;</span><span class="p">,</span> <span class="n">removed</span><span class="o">=</span><span class="s2">&quot;2.0&quot;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">genconfig</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">scheme</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">category</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">settings</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Generate a config string for specified scheme.</span>

<span class="sd">        .. deprecated:: 1.7</span>

<span class="sd">            This method will be removed in version 2.0, and should only</span>
<span class="sd">            be used for compatibility with Passlib 1.3 - 1.6.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">record</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_record</span><span class="p">(</span><span class="n">scheme</span><span class="p">,</span> <span class="n">category</span><span class="p">)</span>
        <span class="n">strip_unused</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_strip_unused_context_kwds</span>
        <span class="k">if</span> <span class="n">strip_unused</span><span class="p">:</span>
            <span class="n">strip_unused</span><span class="p">(</span><span class="n">settings</span><span class="p">,</span> <span class="n">record</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">record</span><span class="o">.</span><span class="n">genconfig</span><span class="p">(</span><span class="o">**</span><span class="n">settings</span><span class="p">)</span>

    <span class="nd">@deprecated_method</span><span class="p">(</span><span class="n">deprecated</span><span class="o">=</span><span class="s2">&quot;1.7&quot;</span><span class="p">,</span> <span class="n">removed</span><span class="o">=</span><span class="s2">&quot;2.0&quot;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">genhash</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">secret</span><span class="p">,</span> <span class="n">config</span><span class="p">,</span> <span class="n">scheme</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">category</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Generate hash for the specified secret using another hash.</span>

<span class="sd">        .. deprecated:: 1.7</span>

<span class="sd">            This method will be removed in version 2.0, and should only</span>
<span class="sd">            be used for compatibility with Passlib 1.3 - 1.6.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">record</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_or_identify_record</span><span class="p">(</span><span class="n">config</span><span class="p">,</span> <span class="n">scheme</span><span class="p">,</span> <span class="n">category</span><span class="p">)</span>
        <span class="n">strip_unused</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_strip_unused_context_kwds</span>
        <span class="k">if</span> <span class="n">strip_unused</span><span class="p">:</span>
            <span class="n">strip_unused</span><span class="p">(</span><span class="n">kwds</span><span class="p">,</span> <span class="n">record</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">record</span><span class="o">.</span><span class="n">genhash</span><span class="p">(</span><span class="n">secret</span><span class="p">,</span> <span class="n">config</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">identify</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">hash</span><span class="p">,</span> <span class="n">category</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">resolve</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">required</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                 <span class="n">unconfigured</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Attempt to identify which algorithm the hash belongs to.</span>

<span class="sd">        Note that this will only consider the algorithms</span>
<span class="sd">        currently configured for this context</span>
<span class="sd">        (see the :ref:`schemes &lt;context-schemes-option&gt;` option).</span>
<span class="sd">        All registered algorithms will be checked, from first to last,</span>
<span class="sd">        and whichever one positively identifies the hash first will be returned.</span>

<span class="sd">        :type hash: unicode or bytes</span>
<span class="sd">        :arg hash:</span>
<span class="sd">            The hash string to test.</span>

<span class="sd">        :type category: str or None</span>
<span class="sd">        :param category:</span>
<span class="sd">            Optional :ref:`user category &lt;user-categories&gt;`.</span>
<span class="sd">            Ignored by this function, this parameter</span>
<span class="sd">            is provided for symmetry with the other methods.</span>

<span class="sd">        :type resolve: bool</span>
<span class="sd">        :param resolve:</span>
<span class="sd">            If ``True``, returns the hash handler itself,</span>
<span class="sd">            instead of the name of the hash.</span>

<span class="sd">        :type required: bool</span>
<span class="sd">        :param required:</span>
<span class="sd">            If ``True``, this will raise a ValueError if the hash</span>
<span class="sd">            cannot be identified, instead of returning ``None``.</span>

<span class="sd">        :returns:</span>
<span class="sd">            The handler which first identifies the hash,</span>
<span class="sd">            or ``None`` if none of the algorithms identify the hash.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">record</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_identify_record</span><span class="p">(</span><span class="nb">hash</span><span class="p">,</span> <span class="n">category</span><span class="p">,</span> <span class="n">required</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">record</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="k">elif</span> <span class="n">resolve</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">unconfigured</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">record</span><span class="o">.</span><span class="n">_Context__orig_handler</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">record</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">record</span><span class="o">.</span><span class="n">name</span>

    <span class="k">def</span> <span class="nf">hash</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">secret</span><span class="p">,</span> <span class="n">scheme</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">category</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;run secret through selected algorithm, returning resulting hash.</span>

<span class="sd">        :type secret: unicode or bytes</span>
<span class="sd">        :arg secret:</span>
<span class="sd">            the password to hash.</span>

<span class="sd">        :type scheme: str or None</span>
<span class="sd">        :param scheme:</span>

<span class="sd">            Optional scheme to use. Scheme must be one of the ones</span>
<span class="sd">            configured for this context (see the</span>
<span class="sd">            :ref:`schemes &lt;context-schemes-option&gt;` option).</span>
<span class="sd">            If no scheme is specified, the configured default</span>
<span class="sd">            will be used.</span>

<span class="sd">            .. deprecated:: 1.7</span>

<span class="sd">                Support for this keyword is deprecated, and will be removed in Passlib 2.0.</span>

<span class="sd">        :type category: str or None</span>
<span class="sd">        :param category:</span>
<span class="sd">            Optional :ref:`user category &lt;user-categories&gt;`.</span>
<span class="sd">            If specified, this will cause any category-specific defaults to</span>
<span class="sd">            be used when hashing the password (e.g. different default scheme,</span>
<span class="sd">            different default rounds values, etc).</span>

<span class="sd">        :param \\*\\*kwds:</span>
<span class="sd">            All other keyword options are passed to the selected algorithm&#39;s</span>
<span class="sd">            :meth:`PasswordHash.hash() &lt;passlib.ifc.PasswordHash.hash&gt;` method.</span>

<span class="sd">        :returns:</span>
<span class="sd">            The secret as encoded by the specified algorithm and options.</span>
<span class="sd">            The return value will always be a :class:`!str`.</span>

<span class="sd">        :raises TypeError, ValueError:</span>
<span class="sd">            * If any of the arguments have an invalid type or value.</span>
<span class="sd">              This includes any keywords passed to the underlying hash&#39;s</span>
<span class="sd">              :meth:`PasswordHash.hash() &lt;passlib.ifc.PasswordHash.hash&gt;` method.</span>

<span class="sd">        .. seealso:: the :ref:`context-basic-example` example in the tutorial</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># XXX: could insert normalization to preferred unicode encoding here</span>
        <span class="k">if</span> <span class="n">scheme</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># TODO: offer replacement alternative.</span>
            <span class="c1">#       ``context.handler(scheme).hash()`` would work,</span>
            <span class="c1">#       but may deprecate .handler() in passlib 1.8.</span>
            <span class="n">warn</span><span class="p">(</span><span class="s2">&quot;CryptContext.hash(): &#39;scheme&#39; keyword is deprecated as of &quot;</span>
                 <span class="s2">&quot;Passlib 1.7, and will be removed in Passlib 2.0&quot;</span><span class="p">,</span>
                 <span class="ne">DeprecationWarning</span><span class="p">)</span>
        <span class="n">record</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_record</span><span class="p">(</span><span class="n">scheme</span><span class="p">,</span> <span class="n">category</span><span class="p">)</span>
        <span class="n">strip_unused</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_strip_unused_context_kwds</span>
        <span class="k">if</span> <span class="n">strip_unused</span><span class="p">:</span>
            <span class="n">strip_unused</span><span class="p">(</span><span class="n">kwds</span><span class="p">,</span> <span class="n">record</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">record</span><span class="o">.</span><span class="n">hash</span><span class="p">(</span><span class="n">secret</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">)</span>

    <span class="nd">@deprecated_method</span><span class="p">(</span><span class="n">deprecated</span><span class="o">=</span><span class="s2">&quot;1.7&quot;</span><span class="p">,</span> <span class="n">removed</span><span class="o">=</span><span class="s2">&quot;2.0&quot;</span><span class="p">,</span> <span class="n">replacement</span><span class="o">=</span><span class="s2">&quot;CryptContext.hash()&quot;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">encrypt</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Legacy alias for :meth:`hash`.</span>

<span class="sd">        .. deprecated:: 1.7</span>
<span class="sd">            This method was renamed to :meth:`!hash` in version 1.7.</span>
<span class="sd">            This alias will be removed in version 2.0, and should only</span>
<span class="sd">            be used for compatibility with Passlib 1.3 - 1.6.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">hash</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">verify</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">secret</span><span class="p">,</span> <span class="nb">hash</span><span class="p">,</span> <span class="n">scheme</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">category</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;verify secret against an existing hash.</span>

<span class="sd">        If no scheme is specified, this will attempt to identify</span>
<span class="sd">        the scheme based on the contents of the provided hash</span>
<span class="sd">        (limited to the schemes configured for this context).</span>
<span class="sd">        It will then check whether the password verifies against the hash.</span>

<span class="sd">        :type secret: unicode or bytes</span>
<span class="sd">        :arg secret:</span>
<span class="sd">            the secret to verify</span>

<span class="sd">        :type hash: unicode or bytes</span>
<span class="sd">        :arg hash:</span>
<span class="sd">            hash string to compare to</span>

<span class="sd">            if ``None`` is passed in, this will be treated as &quot;never verifying&quot;</span>

<span class="sd">        :type scheme: str</span>
<span class="sd">        :param scheme:</span>
<span class="sd">            Optionally force context to use specific scheme.</span>
<span class="sd">            This is usually not needed, as most hashes can be unambiguously</span>
<span class="sd">            identified. Scheme must be one of the ones configured</span>
<span class="sd">            for this context</span>
<span class="sd">            (see the :ref:`schemes &lt;context-schemes-option&gt;` option).</span>

<span class="sd">            .. deprecated:: 1.7</span>

<span class="sd">                Support for this keyword is deprecated, and will be removed in Passlib 2.0.</span>

<span class="sd">        :type category: str or None</span>
<span class="sd">        :param category:</span>
<span class="sd">            Optional :ref:`user category &lt;user-categories&gt;` string.</span>
<span class="sd">            This is mainly used when generating new hashes, it has little</span>
<span class="sd">            effect when verifying; this keyword is mainly provided for symmetry.</span>

<span class="sd">        :param \\*\\*kwds:</span>
<span class="sd">            All additional keywords are passed to the appropriate handler,</span>
<span class="sd">            and should match its :attr:`~passlib.ifc.PasswordHash.context_kwds`.</span>

<span class="sd">        :returns:</span>
<span class="sd">            ``True`` if the password matched the hash, else ``False``.</span>

<span class="sd">        :raises ValueError:</span>
<span class="sd">            * if the hash did not match any of the configured :meth:`schemes`.</span>

<span class="sd">            * if any of the arguments have an invalid value (this includes</span>
<span class="sd">              any keywords passed to the underlying hash&#39;s</span>
<span class="sd">              :meth:`PasswordHash.verify() &lt;passlib.ifc.PasswordHash.verify&gt;` method).</span>

<span class="sd">        :raises TypeError:</span>
<span class="sd">            * if any of the arguments have an invalid type (this includes</span>
<span class="sd">              any keywords passed to the underlying hash&#39;s</span>
<span class="sd">              :meth:`PasswordHash.verify() &lt;passlib.ifc.PasswordHash.verify&gt;` method).</span>

<span class="sd">        .. seealso:: the :ref:`context-basic-example` example in the tutorial</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># XXX: could insert normalization to preferred unicode encoding here</span>
        <span class="c1"># XXX: what about supporting a setter() callback ala django 1.4 ?</span>
        <span class="k">if</span> <span class="n">scheme</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># TODO: offer replacement alternative.</span>
            <span class="c1">#       ``context.handler(scheme).verify()`` would work,</span>
            <span class="c1">#       but may deprecate .handler() in passlib 1.8.</span>
            <span class="n">warn</span><span class="p">(</span><span class="s2">&quot;CryptContext.verify(): &#39;scheme&#39; keyword is deprecated as of &quot;</span>
                 <span class="s2">&quot;Passlib 1.7, and will be removed in Passlib 2.0&quot;</span><span class="p">,</span>
                 <span class="ne">DeprecationWarning</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">hash</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># convenience feature -- let apps pass in hash=None when user</span>
            <span class="c1"># isn&#39;t found / has no hash; useful because it invokes dummy_verify()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">dummy_verify</span><span class="p">()</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="n">record</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_or_identify_record</span><span class="p">(</span><span class="nb">hash</span><span class="p">,</span> <span class="n">scheme</span><span class="p">,</span> <span class="n">category</span><span class="p">)</span>
        <span class="n">strip_unused</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_strip_unused_context_kwds</span>
        <span class="k">if</span> <span class="n">strip_unused</span><span class="p">:</span>
            <span class="n">strip_unused</span><span class="p">(</span><span class="n">kwds</span><span class="p">,</span> <span class="n">record</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">record</span><span class="o">.</span><span class="n">verify</span><span class="p">(</span><span class="n">secret</span><span class="p">,</span> <span class="nb">hash</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">verify_and_update</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">secret</span><span class="p">,</span> <span class="nb">hash</span><span class="p">,</span> <span class="n">scheme</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">category</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;verify password and re-hash the password if needed, all in a single call.</span>

<span class="sd">        This is a convenience method which takes care of all the following:</span>
<span class="sd">        first it verifies the password (:meth:`~CryptContext.verify`), if this is successfull</span>
<span class="sd">        it checks if the hash needs updating (:meth:`~CryptContext.needs_update`), and if so,</span>
<span class="sd">        re-hashes the password (:meth:`~CryptContext.hash`), returning the replacement hash.</span>
<span class="sd">        This series of steps is a very common task for applications</span>
<span class="sd">        which wish to update deprecated hashes, and this call takes</span>
<span class="sd">        care of all 3 steps efficiently.</span>

<span class="sd">        :type secret: unicode or bytes</span>
<span class="sd">        :arg secret:</span>
<span class="sd">            the secret to verify</span>

<span class="sd">        :type secret: unicode or bytes</span>
<span class="sd">        :arg hash:</span>
<span class="sd">            hash string to compare to.</span>

<span class="sd">            if ``None`` is passed in, this will be treated as &quot;never verifying&quot;</span>

<span class="sd">        :type scheme: str</span>
<span class="sd">        :param scheme:</span>
<span class="sd">            Optionally force context to use specific scheme.</span>
<span class="sd">            This is usually not needed, as most hashes can be unambiguously</span>
<span class="sd">            identified. Scheme must be one of the ones configured</span>
<span class="sd">            for this context</span>
<span class="sd">            (see the :ref:`schemes &lt;context-schemes-option&gt;` option).</span>

<span class="sd">            .. deprecated:: 1.7</span>

<span class="sd">                Support for this keyword is deprecated, and will be removed in Passlib 2.0.</span>

<span class="sd">        :type category: str or None</span>
<span class="sd">        :param category:</span>
<span class="sd">            Optional :ref:`user category &lt;user-categories&gt;`.</span>
<span class="sd">            If specified, this will cause any category-specific defaults to</span>
<span class="sd">            be used if the password has to be re-hashed.</span>

<span class="sd">        :param \\*\\*kwds:</span>
<span class="sd">            all additional keywords are passed to the appropriate handler,</span>
<span class="sd">            and should match that hash&#39;s</span>
<span class="sd">            :attr:`PasswordHash.context_kwds &lt;passlib.ifc.PasswordHash.context_kwds&gt;`.</span>

<span class="sd">        :returns:</span>
<span class="sd">            This function returns a tuple containing two elements:</span>
<span class="sd">            ``(verified, replacement_hash)``. The first is a boolean</span>
<span class="sd">            flag indicating whether the password verified,</span>
<span class="sd">            and the second an optional replacement hash.</span>
<span class="sd">            The tuple will always match one of the following 3 cases:</span>

<span class="sd">            * ``(False, None)`` indicates the secret failed to verify.</span>
<span class="sd">            * ``(True, None)`` indicates the secret verified correctly,</span>
<span class="sd">              and the hash does not need updating.</span>
<span class="sd">            * ``(True, str)`` indicates the secret verified correctly,</span>
<span class="sd">              but the current hash needs to be updated. The :class:`!str`</span>
<span class="sd">              will be the freshly generated hash, to replace the old one.</span>

<span class="sd">        :raises TypeError, ValueError:</span>
<span class="sd">            For the same reasons as :meth:`verify`.</span>

<span class="sd">        .. seealso:: the :ref:`context-migration-example` example in the tutorial.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># XXX: could insert normalization to preferred unicode encoding here.</span>
        <span class="k">if</span> <span class="n">scheme</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">warn</span><span class="p">(</span><span class="s2">&quot;CryptContext.verify(): &#39;scheme&#39; keyword is deprecated as of &quot;</span>
                 <span class="s2">&quot;Passlib 1.7, and will be removed in Passlib 2.0&quot;</span><span class="p">,</span>
                 <span class="ne">DeprecationWarning</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">hash</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># convenience feature -- let apps pass in hash=None when user</span>
            <span class="c1"># isn&#39;t found / has no hash; useful because it invokes dummy_verify()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">dummy_verify</span><span class="p">()</span>
            <span class="k">return</span> <span class="kc">False</span><span class="p">,</span> <span class="kc">None</span>
        <span class="n">record</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_or_identify_record</span><span class="p">(</span><span class="nb">hash</span><span class="p">,</span> <span class="n">scheme</span><span class="p">,</span> <span class="n">category</span><span class="p">)</span>
        <span class="n">strip_unused</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_strip_unused_context_kwds</span>
        <span class="k">if</span> <span class="n">strip_unused</span> <span class="ow">and</span> <span class="n">kwds</span><span class="p">:</span>
            <span class="n">clean_kwds</span> <span class="o">=</span> <span class="n">kwds</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">strip_unused</span><span class="p">(</span><span class="n">clean_kwds</span><span class="p">,</span> <span class="n">record</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">clean_kwds</span> <span class="o">=</span> <span class="n">kwds</span>
        <span class="c1"># XXX: if record is default scheme, could extend PasswordHash</span>
        <span class="c1">#      api to combine verify &amp; needs_update to single call,</span>
        <span class="c1">#      potentially saving some round-trip parsing.</span>
        <span class="c1">#      but might make these codepaths more complex...</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">record</span><span class="o">.</span><span class="n">verify</span><span class="p">(</span><span class="n">secret</span><span class="p">,</span> <span class="nb">hash</span><span class="p">,</span> <span class="o">**</span><span class="n">clean_kwds</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">False</span><span class="p">,</span> <span class="kc">None</span>
        <span class="k">elif</span> <span class="n">record</span><span class="o">.</span><span class="n">deprecated</span> <span class="ow">or</span> <span class="n">record</span><span class="o">.</span><span class="n">needs_update</span><span class="p">(</span><span class="nb">hash</span><span class="p">,</span> <span class="n">secret</span><span class="o">=</span><span class="n">secret</span><span class="p">):</span>
            <span class="c1"># NOTE: we re-hash with default scheme, not current one.</span>
            <span class="k">return</span> <span class="kc">True</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">hash</span><span class="p">(</span><span class="n">secret</span><span class="p">,</span> <span class="n">category</span><span class="o">=</span><span class="n">category</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">True</span><span class="p">,</span> <span class="kc">None</span>

    <span class="c1">#===================================================================</span>
    <span class="c1"># missing-user helper</span>
    <span class="c1">#===================================================================</span>

    <span class="c1">#: secret used for dummy_verify()</span>
    <span class="n">_dummy_secret</span> <span class="o">=</span> <span class="s2">&quot;too many secrets&quot;</span>

    <span class="nd">@memoized_property</span>
    <span class="k">def</span> <span class="nf">_dummy_hash</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        precalculated hash for dummy_verify() to use</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">hash</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_dummy_secret</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_reset_dummy_verify</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        flush memoized values used by dummy_verify()</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">_dummy_hash</span><span class="o">.</span><span class="n">clear_cache</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">dummy_verify</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">elapsed</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Helper that applications can call when user wasn&#39;t found,</span>
<span class="sd">        in order to simulate time it would take to hash a password.</span>

<span class="sd">        Runs verify() against a dummy hash, to simulate verification</span>
<span class="sd">        of a real account password.</span>

<span class="sd">        :param elapsed:</span>

<span class="sd">            .. deprecated:: 1.7.1</span>

<span class="sd">                this option is ignored, and will be removed in passlib 1.8.</span>

<span class="sd">        .. versionadded:: 1.7</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">verify</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_dummy_secret</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dummy_hash</span><span class="p">)</span>
        <span class="k">return</span> <span class="kc">False</span>

    <span class="c1">#===================================================================</span>
    <span class="c1"># disabled hash support</span>
    <span class="c1">#===================================================================</span>

    <span class="k">def</span> <span class="nf">is_enabled</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">hash</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        test if hash represents a usuable password --</span>
<span class="sd">        i.e. does not represent an unusuable password such as ``&quot;!&quot;``,</span>
<span class="sd">        which is recognized by the :class:`~passlib.hash.unix_disabled` hash.</span>

<span class="sd">        :raises ValueError:</span>
<span class="sd">            if the hash is not recognized</span>
<span class="sd">            (typically solved by adding ``unix_disabled`` to the list of schemes).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_identify_record</span><span class="p">(</span><span class="nb">hash</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span><span class="o">.</span><span class="n">is_disabled</span>

    <span class="k">def</span> <span class="nf">disable</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">hash</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        return a string to disable logins for user,</span>
<span class="sd">        usually by returning a non-verifying string such as ``&quot;!&quot;``.</span>

<span class="sd">        :param hash:</span>
<span class="sd">            Callers can optionally provide the account&#39;s existing hash.</span>
<span class="sd">            Some disabled handlers (such as :class:`!unix_disabled`)</span>
<span class="sd">            will encode this into the returned value,</span>
<span class="sd">            so that it can be recovered via :meth:`enable`.</span>

<span class="sd">        :raises RuntimeError:</span>
<span class="sd">            if this function is called w/o a disabled hasher</span>
<span class="sd">            (such as :class:`~passlib.hash.unix_disabled`) included</span>
<span class="sd">            in the list of schemes.</span>

<span class="sd">        :returns:</span>
<span class="sd">            hash string which will be recognized as valid by the context,</span>
<span class="sd">            but is guaranteed to not validate against *any* password.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">record</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_config</span><span class="o">.</span><span class="n">disabled_record</span>
        <span class="k">assert</span> <span class="n">record</span><span class="o">.</span><span class="n">is_disabled</span>
        <span class="k">return</span> <span class="n">record</span><span class="o">.</span><span class="n">disable</span><span class="p">(</span><span class="nb">hash</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">enable</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">hash</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        inverse of :meth:`disable` --</span>
<span class="sd">        attempts to recover original hash which was converted</span>
<span class="sd">        by a :meth:`!disable` call into a disabled hash --</span>
<span class="sd">        thus restoring the user&#39;s original password.</span>

<span class="sd">        :raises ValueError:</span>
<span class="sd">            if original hash not present, or if the disabled handler doesn&#39;t</span>
<span class="sd">            support encoding the original hash (e.g. ``django_disabled``)</span>

<span class="sd">        :returns:</span>
<span class="sd">            the original hash.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">record</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_identify_record</span><span class="p">(</span><span class="nb">hash</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">record</span><span class="o">.</span><span class="n">is_disabled</span><span class="p">:</span>
            <span class="c1"># XXX: should we throw error if result can&#39;t be identified by context?</span>
            <span class="k">return</span> <span class="n">record</span><span class="o">.</span><span class="n">enable</span><span class="p">(</span><span class="nb">hash</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># hash wasn&#39;t a disabled hash, so return unchanged</span>
            <span class="k">return</span> <span class="nb">hash</span>

    <span class="c1">#===================================================================</span>
    <span class="c1"># eoc</span>
    <span class="c1">#===================================================================</span>

<span class="k">class</span> <span class="nc">LazyCryptContext</span><span class="p">(</span><span class="n">CryptContext</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;CryptContext subclass which doesn&#39;t load handlers until needed.</span>

<span class="sd">    This is a subclass of CryptContext which takes in a set of arguments</span>
<span class="sd">    exactly like CryptContext, but won&#39;t import any handlers</span>
<span class="sd">    (or even parse its arguments) until</span>
<span class="sd">    the first time one of its methods is accessed.</span>

<span class="sd">    :arg schemes:</span>
<span class="sd">        The first positional argument can be a list of schemes, or omitted,</span>
<span class="sd">        just like CryptContext.</span>

<span class="sd">    :param onload:</span>

<span class="sd">        If a callable is passed in via this keyword,</span>
<span class="sd">        it will be invoked at lazy-load time</span>
<span class="sd">        with the following signature:</span>
<span class="sd">        ``onload(**kwds) -&gt; kwds``;</span>
<span class="sd">        where ``kwds`` is all the additional kwds passed to LazyCryptContext.</span>
<span class="sd">        It should perform any additional deferred initialization,</span>
<span class="sd">        and return the final dict of options to be passed to CryptContext.</span>

<span class="sd">        .. versionadded:: 1.6</span>

<span class="sd">    :param create_policy:</span>

<span class="sd">        .. deprecated:: 1.6</span>
<span class="sd">            This option will be removed in Passlib 1.8,</span>
<span class="sd">            applications should use ``onload`` instead.</span>

<span class="sd">    :param kwds:</span>

<span class="sd">        All additional keywords are passed to CryptContext;</span>
<span class="sd">        or to the *onload* function (if provided).</span>

<span class="sd">    This is mainly used internally by modules such as :mod:`passlib.apps`,</span>
<span class="sd">    which define a large number of contexts, but only a few of them will be needed</span>
<span class="sd">    at any one time. Use of this class saves the memory needed to import</span>
<span class="sd">    the specified handlers until the context instance is actually accessed.</span>
<span class="sd">    As well, it allows constructing a context at *module-init* time,</span>
<span class="sd">    but using :func:`!onload()` to provide dynamic configuration</span>
<span class="sd">    at *application-run* time.</span>

<span class="sd">    .. note:: </span>
<span class="sd">        This class is only useful if you&#39;re referencing handler objects by name,</span>
<span class="sd">        and don&#39;t want them imported until runtime. If you want to have the config</span>
<span class="sd">        validated before your application runs, or are passing in already-imported</span>
<span class="sd">        handler instances, you should use :class:`CryptContext` instead.</span>

<span class="sd">    .. versionadded:: 1.4</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">_lazy_kwds</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="c1"># NOTE: the way this class works changed in 1.6.</span>
    <span class="c1">#       previously it just called _lazy_init() when ``.policy`` was</span>
    <span class="c1">#       first accessed. now that is done whenever any of the public</span>
    <span class="c1">#       attributes are accessed, and the class itself is changed</span>
    <span class="c1">#       to a regular CryptContext, to remove the overhead once it&#39;s unneeded.</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">schemes</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">schemes</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">kwds</span><span class="p">[</span><span class="s1">&#39;schemes&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">schemes</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_lazy_kwds</span> <span class="o">=</span> <span class="n">kwds</span>

    <span class="k">def</span> <span class="nf">_lazy_init</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">kwds</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_lazy_kwds</span>
        <span class="k">if</span> <span class="s1">&#39;create_policy&#39;</span> <span class="ow">in</span> <span class="n">kwds</span><span class="p">:</span>
            <span class="n">warn</span><span class="p">(</span><span class="s2">&quot;The CryptPolicy class, and LazyCryptContext&#39;s &quot;</span>
                 <span class="s2">&quot;``create_policy`` keyword have been deprecated as of &quot;</span>
                 <span class="s2">&quot;Passlib 1.6, and will be removed in Passlib 1.8; &quot;</span>
                 <span class="s2">&quot;please use the ``onload`` keyword instead.&quot;</span><span class="p">,</span>
                 <span class="ne">DeprecationWarning</span><span class="p">)</span>
            <span class="n">create_policy</span> <span class="o">=</span> <span class="n">kwds</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;create_policy&quot;</span><span class="p">)</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">create_policy</span><span class="p">(</span><span class="o">**</span><span class="n">kwds</span><span class="p">)</span>
            <span class="n">policy</span> <span class="o">=</span> <span class="n">CryptPolicy</span><span class="o">.</span><span class="n">from_source</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">_warn</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="n">kwds</span> <span class="o">=</span> <span class="n">policy</span><span class="o">.</span><span class="n">_context</span><span class="o">.</span><span class="n">to_dict</span><span class="p">()</span>
        <span class="k">elif</span> <span class="s1">&#39;onload&#39;</span> <span class="ow">in</span> <span class="n">kwds</span><span class="p">:</span>
            <span class="n">onload</span> <span class="o">=</span> <span class="n">kwds</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;onload&quot;</span><span class="p">)</span>
            <span class="n">kwds</span> <span class="o">=</span> <span class="n">onload</span><span class="p">(</span><span class="o">**</span><span class="n">kwds</span><span class="p">)</span>
        <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">_lazy_kwds</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">LazyCryptContext</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="o">**</span><span class="n">kwds</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span> <span class="o">=</span> <span class="n">CryptContext</span>

    <span class="k">def</span> <span class="fm">__getattribute__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">attr</span><span class="p">):</span>
        <span class="k">if</span> <span class="p">(</span><span class="ow">not</span> <span class="n">attr</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;_&quot;</span><span class="p">)</span> <span class="ow">or</span> <span class="n">attr</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;__&quot;</span><span class="p">))</span> <span class="ow">and</span> \
            <span class="bp">self</span><span class="o">.</span><span class="n">_lazy_kwds</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_lazy_init</span><span class="p">()</span>
        <span class="k">return</span> <span class="nb">object</span><span class="o">.</span><span class="fm">__getattribute__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">attr</span><span class="p">)</span>

<span class="c1">#=============================================================================</span>
<span class="c1"># eof</span>
<span class="c1">#=============================================================================</span>
</pre></div>

            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<search id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</search>
<script>document.getElementById('searchbox').style.display = "block"</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../index.html">contacts_api 0.1 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../index.html" >Module code</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">passlib.context</a></li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
    &#169; Copyright 2024, Szczepan.
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 7.3.7.
    </div>
  </body>
</html>